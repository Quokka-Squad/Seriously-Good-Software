# 재사용성

- 소프트웨어의 구성 요소를 폭넓은 상황에 적용할 수 있게 일반화하기
- `제네릭`을 이용해 `재사용` 가능한 클래스 만들기
- `데이터 스트림`을 `가변 컬렉터`를 사용하고 용도에 맞게 바꾸기

## 일반적인 프레임워크

### 속성 관리 API

### 메서드 참조

- 이미 존재하는 메서드나 생성자를 함수형 인터페이스의 인스턴스로 변환하는 람다 표현식
- 2중 콜론 `::`으로 표기한다.
- `클래스 이름::메서드이름` 또는 `참조변수이름::메서드이름`

Method Reference 3가지 유형
1. 정적 메서드 참조 : Integer의 parseInt를 Integer::parseInt로 사용 가능
2. 다양한 형식의 인스턴스 메서드 참조 : String의 length 메서드를 String::length로 사용 가능
3. 기존 객체의 인스턴스 메서드 참조 : Transaction 객체를 할당받은 transaction 지역 변수가 있고, Transaction 객체에는 getValue 메서드가 있다면, transaction::getValue로 사용 가능

[메서드 참조 블로그](https://countryxide.tistory.com/127)

## 제네릭 컨테이너 구현
## 일반적인 고려사항
## 수조의 기능 재현하기
## 소셜 네트워크 포스트
## 전혀 새로운 문제에 적용해보기
## 실제 사례

### 돌발 퀴즈 1

Q) Employee 클래스에 public boolean equals(Employee e)를 추가하는 것은 좋은 선택일까, 아닐까? 그 이유는? <br>
-> `정답` equals 메서드를 넣는 방식은 좋지 않다. 우선 Object의 equals를 오버라이딩하는 것이 아니라 오버로딩한다.
<br>
```
Employee alx = ..., beth = ...;
alex.equals(beth);  // 내용 기반 비교
alex.equals((Object) beth); // 식별성 기반 비교
```
이러한 상황은 오류의 소지가 크고 프로그래머의 의도와 맞지 않다.

### 돌발 퀴즈 2

Q) 타입 파라미터 T에 대해 자바에서 T 타입의 배열을 할당할 수 있는가? C#에서는 어떠한가? <br>
-> `정답` 자바에서는 타입 파라미터 T에 대해 `타입 T의 배열`을 할당 할 수 없다. 배열을 `런타임`에 수행되는 모든 `쓰기 연산`과 `타입 변환`의 `적법성`을 검사하기 위해 타입 정보를 저장하고 사용. `타입 제거 방식`에서는 `런타임`에 실제 T의 값을 `바이트코드`에 저장하지 않으므로 배열의 런타임 검사 매커니즘이 동작하지 않는다. 하지만 `T[] 타입`의 변수를 선언만 하는 것은 완전하게 적법하니 혼동하지 말자.

### 돌발 퀴즈 3

Q) 컬렉터에서 combiner 메서드의 역할은 무엇이며 언제 사용하는가? <br>
-> `combiner` 메서드를 사용하는 컬렉터는 `병렬 컬렉터`뿐이다. 이 메서드는 `스트림 연산`을 수행하기 위해 서로 협동하는 `각각의 스레드`에서 만든 `부분적인 결과`를 `하나로 병합`할 수 있는 `객체`를 리턴.

### 돌발 퀴즈 4

Q) 메서드 참조를 Object 타입의 변수로 할 수 있을까 <br>
-> `정답` 노우.
```
Object x = String::length; // 컴파일 오류

Object x = (ToIntFunction<String>) String::length;  // 필요하다면 타입 변환을 이용
```
