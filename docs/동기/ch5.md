# 모니터링을 이용한 신뢰성 향상

> 계약 형태로 메서드 명세 작성하기 <br>
> 런타임에 계약 준수 강제하기 <br>
> 어서션 사용하기 <br>
> 사후 조건의 가벼운 대안으로서 클래스 불변 조건 확인하기 <br>

## 계약에 의한 설계

### 사전 조건과 사후 조건

- 사전 조건 (precondition)
  - 메서드가 호출되기 위해 만족돼야 하는 조건.
  - 메서드의 요구사항을 명시하고 이것이 만족되지 않을 경우 메서드가 실행되서는 안 된다.
  - 사전조건을 만족시키는 것은 메서드를 실행하는 클라이언트의 의무다.
- 사후 조건 (postcondition)
  - 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건.
  - 클라이언트가 사전조건을 만족시켰다면 메서드는 사후조건에 명시된 조건을 만족시켜야 한다.
  - 만약 클라이언트가 사전조건을 만족시켰는데도 사후조건을 만족시키지 못한 경우에는 클라이언트에게 예외를 던져야 한다. 
  - 사후조건을 만족시키는 것은 서버의 의무다.

### 불변 조건
- 클래스 필드에 대해 항상 참이 조건
  - 메서드가 실행되는 동안 클래스가 변화하는 동안을 제외하고 항상 성립해야 한다.
- 특정 시점의 객체 상태를 기술하는 정적 일관성 규칙.
  - 사후 조건은 메서드 실행 전후의 객체 상태를 비교하므로 동적 일관성 규칙이다.

### 정확성과 견고성
- 정확성
  - 정확성을 측정할 때는 시스템이 정상 환경이라고 가정한다.
    - 시스템이 정확하다는 것은 기대한 환경이 주어진다는 가정하에 시스템이 계획대로 작동한다는 뜻.
  - 일반적으로 `Boolean` 속성이다.
- 견고성
  - 예외적이고 예상하지 못한 환경에서 시스템이 어떻게 동작하는지를 다룬다.
    - 외부에서 주어진 입력의 형식이나 범위가 틀린 경우 사전 조건이 깨진 상태에서 메서드가 호출되는 상황을 예로 들 수 있다.
    - 견고한 시스템은 이러한 상황에서 `gracefully` `우아하게` 동작해야한다. 
---
계약을 구현하고 강제하는데 도움을 주는 코딩 기법
- if 조건문은 호출자가 사전 조건을 지키는 방식으로 메서드를 호출 했는지 확인하고 그렇지 않으면 페널티를 발생시킨다.
- assert 구문은 사전 조건과 불변 조건을 확인하는데 유용하며 안전이 중요한 소프트웨어에서 쓸모 있다.
- 테스트는 소프트웨어의 신뢰성에 대한 확신을 높여줄 수 있으며 사후 조건을 검사하고 페널티를 발생시킨다.

### 계약 검사
- 프로그램 오류의 상당수는 메서드 사전 조건 위반에서 발생한다.
  - 이를 빨리 드러내려면 메서드가 런타임에 사전 조건을 확인하고 조건을 어기면 적절한 예외를 던져야한다. (방어적 프로그래밍)
    - `IllegalArgumentException` 인자 값이 사전 조건을 위반함
    - `IllegalStateException` 현재의 객체 상태가 호출된 인스턴스 메서드와 호환되지 않거나 주어진 인자 값과 호환되지 않는다. 이미 닫힌 파일에 읽기를 시도하면 이러한 예외가 발생한다. 
- if 기반 검사는 항상 실행되지만 `assertion` 으로 실행되는 검사는 매번 끄거나 켤 수 있다.
  - 일반적으로 개발할 때 assertion을 `활성화` 하고 배포할 때는 `비활성화` 한다.
  - 배포를 비롯한 모든 경우에 항상 수행해야 하는 검사도 존재한다.

<br>
계약에 의한 설계는 어떠한 검사가 항상 수행돼야 하는지 기준을 제공한다.

- public 메서드의 사전 조건은 항상 확인해야 하므로 if를 이용한다.
- 사후 조건과 불변 조건, public이 아닌 메서드의 사전 조건을 비롯한 다른 모든 확인은 개발하는 동안에만 수행한다. `assertion` 을 이용한다.

<br>
사전 조건 위반은 메서드 계약을 준수하지 않는 클라이언트로 인해 발생.
<br>
사후 조건과 불변 조건 위반은 클래스 자체의 문제.
<br>
<br>

- 개발 프로세스의 품질과 강도가 높을수록 가정이 성립할 확률도 높다.
  - `개발 프로세스의 품질`이란 개발자가 업계의 우수 사례를 따르는지 여부.
     - 개발 프로세스의 강도, 테스트에 소모된 인력과 시간을 말한다.
     - 내부적인 문제로 자유롭기 위해서 클래스가 작아야 한다. (OOP)

<br>
<br>

![IMG_7BF6EF362AC2-1](https://user-images.githubusercontent.com/73376468/152285971-6a303918-5c61-4fd8-8a7b-d0669853fffa.jpeg)

- 수동검증
  - 동료 개발자가 회사 표준에 따라 코드를 검증하는 것. (코드 리뷰)
  - 이 검토를 주기적으로나 지속적으로 수행할 수 있다. (짝 프로그래밍)

- 자동검증
  - 소프트웨어 도구를 이용해 컴파일러가 수행하는 확인에 더해 코드 속성을 자동으로 검증.
    - 스타일 검사기(style checker)
      - 가독성과 통일성을 목적으로 상대적으로 표면적인 속성을 검사하는 도구.
      - 신뢰성과 유지보수성에 간접적으로 이득을 줌.
      - 기능 예시 : 들여쓰기가 올바로 통일됐는지 검사.
    - 정적 분석기(static analyzer)
      - 컴파일러의 타입 검사 단계와 같은 의미론적 분석이 가능한 도구.
      - 위의 스타일 검사기와 정적 분석기를 린터(linter)라고도 한다.
      - 기능 예시 : 익명 클래스에 호출 불가능한 메서드가 있는지 검사
      - spotbugs, sonarqube
    - 형식 검증기(formal verifier)
      - 학술적 연구에서 유래한 도구. 컴파일러보다 프로그램을 깊이 히해함. 주어진 모든 값의 집합에 대해 프로그램 실행을 시뮬레이션 할 수 있다. 기호적 실행 (symbolic execution)
      - 기능 예시 : 정수 변수가 음수가 될 수 있는지 검사

## 계약을 바탕으로 수조 설계하기



### 돌발 퀴즈 1
Q) 페널티로 확인된 예외를 던지지 않는 이유는 무엇일까? <br>
->

### 돌발 퀴즈 2
Q) 프로그램이 종이에 인쇄한다면 종이가 떨어졌을 때 우아한 대처법은 무엇일까? <br>
-> 종이가 떨어졌다는 에러를 출력해준다.