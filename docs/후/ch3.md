# 3장\_질주 본능: 시간 효율성

### ✔️ check point

- 리스트와 집합, 트리를 비롯한 일반적인 자료 구조 사이의 성능 비교
- 주어진 자료 구조의 최악의 경우 성능과 장기적인 평균 성능 평가
- 클래스의 특정 메서드에 계산 부하를 집중시키거나 여러 메서드로 분산하기

---

> 모든 상황에서 최선, 최적의 방법은 존재하지 않는다. 상충하는 대안이 존재할 뿐

## 부분 순서

- 여러 메서드가 존재하는 경우 여러 구현 방식 사이에서 복잡도(최악의 경우)에 부분 순서 관계가 성립
- 부분 순서 : 여러 항목 중 둘을 뽑았을 때 둘 사이에 성립하는 관계로 그중 일부 쌍이 비교 불가한 관계
  - ex) 자바의 확대 변환 규칙 `int`는 `long`보다 작고(변환할 수 있고) `boolean`과 `int`는 비교 불가
- 부분 순서를 따르는 어떠한 관계에서 비교 가능한 집합 안에서 다른 어떠한 항복모다 작지 않은 항목을 극대 원소(top item)(= 파레토 최적, pareto optimal)라고 한다.
  - ex) 아담과 이브는 다른 누구보다 작지 않으므로(자손이 아니므로) 유일한 극대 원소
- 모든 파레토 최적 항목의 집합을 파레토 경계(pareto fromt)라고 한다.
- 클래스를 설계할 때 메서드의 호출 빈도와 호출 순서를 알 수 없다면 성능 특성이 파레토 최적인 구현 방식을 선택하는 것이 최선

## 수조 예제 시간 복잡도 개선 아이디어

### addWater 개선

- 필드를 다른 클래스로 분리
  - 물의 양을 더할 때(`addWater`), 연결된 모든 수조에 단긴 물의 양이 같은 경우 모든 수조를 순회(O(n))하며 물의 양에 접근하지 않아도, `Group` 클래스를 새로 만들어서 같은 그룹에 속한 물의 양을 저장하면 해당 그룹에 속하는 물의 양을 한 번만 찾아도 된다(O(1)).
    - 수조를 연결할 때(`connectTo`) 그룹에 속한 모든 수조를 순회해야 하므로 시간 복잡도는 결국 O(n)

### connectTo 개선

- 다른 자료구조 사용
  - 수조를 연결할 때(`connectTo`)를 다른 자료구조(순환 연결 리스트)를 사용하면 참조를 교체하는 것 만으로 리스트를 병합할 수 있다(O(n))
    - 주어진 두 노드가 서로 다른 리스트에 속할 때(직/간접적으로 연결되지 않은 경우)만 제대로 작동
    - 병합하기 전에 주어진 두 수조가 연결됬는지 확인하려면 두 리스트 중 적어도 하나를 스캔해야 하므로 O(n).
    - 상수 시간의 성능을 원한다면 이러한 견고성의 결함을 감내해야 함
- 갱신 지연(필요한 시점까지 계산 미루기)

  - 수조를 연결할 때(`connectTo`) 상수 시간에 실행하기 위해 물의 양을 갱신하지 않음.
  - 물의 양은 `getAmount`를 호출할 때 비로소 알 수 있으며, 이를 지연성(laziness)나 지연 평가(lazy evaluation)라고 함(함수형 프로그래밍 유래)
  - 표준 자바 컬렉션은 지연의 반대 개념인 즉시성(eager)을 띤다.

    - 자바8에서는 데이터 시퀀스를 다루는 강력한 프레임워크인 스트림 라이브러리를 제공하는데 여러 가지 기능 중에서도 지연 평가를 채택

    ```java
    list.sort(null); // 리스트가 즉시성을 띠므로 정렬을 즉히 수행

    Stream<Integer> stream = list.stream();
    Stream<Integer> sortedStream = stream.sorted();
    ```

    - 정렬을 바로 수행하지 않음. `sorted` 메서드는 결과적으로 데이터가 정렬돼야 한다는 것을 나타내는 플래그(flag)를 설정
    - 스트림을 컬렉션으로 다시 변환하거나 어떠한 식으로든 요소를 순회할 때 정렬을 수행

### 두 메서드 사이 균형의 수호자

- 합집합 찾기 알고리즘 → 최적의 성능 발휘
  - 분리된 다수의 집합을 다루는데 집합마다 특별하게 선택된 대표 요소가 존재하며 다음과 같은 2가지 연산을 제공
    - 두 집합을 병합(union) : 크기에 따른 연결(link-by-size) 정책
    - 주어진 요소가 속하는 집합의 대표 찾기(find) : 경로 압축(path comparison) 기법
      - 트리 탐색 도중 만나는 모든 노드를 루트의 직계 자녀로 만드는 방식
      - 트리를 탐색하는 동안 다음에 연산을 더 효율적으로 수행할 수 있도록 트리를 변경
  - 수조의 그룹을 트리 형태로 표현. 각 수조는 트리 안에서의 부모만 참조하고, 각 트리의 root가 그룹의 대표가 된다(대표 수조에는 트리의 크기도 저장).
  - 부모 포인터 트리
    - 각 노드가 부모 노드 하나만 가리키는 식으로 데이터가 연결된 자료 구조
    - 어떤 노드에서든 포인터를 계속 따라가면 루트에 이를 수 있음
    - 순환 경로(cycle)가 존재X 무향 무순환 그래프(DAG, Directed Acyclic Graph)의 일종
    - 리프(leaf) : 자식이 없는 노드
    - 각 노드가 부모를 참조하지만 자식의 참조는 저장하지 않음(리프→루트 방향으로만 탐색 가능)
    - 트리의 높이 : 어떠한 노드에서 루트에 이르는 최장 경로의 길이

### 결론

- 어떤 구현도 다른 구현을 압도적으로 이기지는 못하며, 어떤 두 구현을 비교해도 한 메서드의 성능은 개선되는 반면 다른 메서드의 복잡도는 높아진다. (=파레토 최적)
- 응용 환경과 클라이언트의 메서드별 호출 빈도를 분석해서 선택
- 메서드를 호출하는 클라이언트와 지속적인 상호작용을 하는 클래스를 설계할 때는 각 메서드의 복잡도를 따로 고려하는 것만으로는 충분하지 않다.
  1. 메서드 사이의 성능이 서로 영향을 미친다. 즉, 한 메서드를 빠르게 하면 다른 메서드가 느려진다. → 메서드 사이의 상호작용
     - 복잡도 분석과 사용량 프로파일 분석을 병행하는 것이 가장 좋다.
     - 사용량 프로파일에 포함되는 클래스 메서드의 수행 빈도와 실행 순서 등의 정보들을 통해 클라이언트와 클래스의 상호작용에서 나타나는 특성을 알 수 있다.
  2. 다음 실행을 빠르게 하기 위해 당장의 시간을 투자할 수 있다.
     - 분할상환 분석을 바탕으로 장기적으로 나타나는 시간투자 효과를 평가
- 실용적인 관점에서 가장 쉬운 방법은 **여러 방식을 구현해보고 프로파일링**하는 것!

## 분할상환 시간 복잡도

- 여러 메서드로 이뤄진 연산이 임의의 횟수만큼 여러 번 수행되는 경우를 고려. 추가적인 연산을 바탕으로 미래의 효율성을 높이는 알고리즘에 적합
  - 추가적인 연산 → 미래의 이득을 얻기 위한 투자
  - 알고리즘이 한 번 실행되는 경우를 분석한다면(ex. 최악의 경우) 당장의 비용은 고려하지만 미래의 이득은 고려하지 않음
  - but, 분할상환 분석은 연산이 여러 번 실행되는 상황을 고려함으로써 현재의 비용과 미래의 이득을 모두 따짐
- ex) `ArrayList` 배열을 키워야 할 때마다 요소 하나를 더하지 않고 50%씩 커진다. 이러한 전략 덕분에 분할상환 복잡도를 낮출 수 있다.
  - 삽입을 n번 수행하는 비용은 n에 선형적으로 비례하며 장기적으로 삽입을 한 번 수행하는 평균 비용은 상수
  - 장기적으로 삽입 연산 한 번의 비용은 상수지만 일련의 삽입 연산 사이의 성능 차가 심하다(가끔 기존에 삽입한 모든 요소를 복사하는 작업 수행) → 시간에 따른 변동성이 큰 고처리량(high jitter high throughput) 연산
  - ↔  `LinkedList`의 삽입 연산 처리량은 비슷하지만 모든 삽입 연산의 수행시간이 같으므로 시간에 따른 변동성이 기본적으로 없음

## 평균적인 경우 시간 복잡도

- 주어진 알고리즘에 대해 최악의 경우보다 가능한 모든 입력의 평균 복잡도를 구하는데 초점을 맞춤
- 이때 모든 입력은 같은 확률로 등장한다고 가정

## 자바(VM에서 실행하는 언어) 프로그램 성능 비교

- 자바를 비롯해 VM에서 실행하는 언어로 작성된 프로그램의 성능을 비교할 때는 컴파일러와 VM 모두 프로그램에 큰 변경을 가할 수 있으므로 몇 가지를 주의해야 한다.
  - 컴파일러는 가시적인 효과가 없다고 확인된 코드는 생략할 수 있음
  - VM은 바이트코드 해석과 네이티브 코드 컴파일 사이에서 자유롭게 오갈 수 있음(JIT 컴파일)
- 이는 다음과 같이 조치한다.
  - 각 연산이 화면 출력이나 파일 쓰기처럼 가시적인 효과를 일으키게 한다.
  - 시간을 측정하기 전에 측정할 코드를 미리 여러 번 수행(준비 실행, dry run)하여 VM이 성능에 미치는 영향이 큰 부분을 컴파일하게 유도함으로써 더 의미 있는 시간 측정
- +) 자바 마이크로 벤치마킹 도구(JMH, Java Micro benchmarking Harness)라는 표준 벤치마킹 프레임워크가 자바에 포함되는데, 컴파일러 VM의 최적화를 세세하게 조정할 수 있다
  - 자바코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크. OpenJDK에서 개발한 성능 측정 툴
    - [JMH 사용해보기](https://javabom.tistory.com/75)

## 퀴즈 & 연습 문제

### ‼️ **[돌발 퀴즈 1]** 자바 프로그램에서 사용하는 클래스 사이에는 어떠한 부분 순서가 성립할까?

→ 극대 원소 `Object`를 상속받은 하위클래스들

⇒ 자바 프로그램 클래스 사이에는 2가지 부분순서가 성립한다.

1. ‘~의 서브클래스’
2. ‘~의 내부클래스’

### ‼️ **[돌발 퀴즈 2]** 단일 순환 연결 리스트에서 주어진 노드를 제거하는 연산의 복잡도는 어떠한가?

→ O(n).

- 최악의 경우 연결리스트의 길이만큼 순회하며 `next`가 주어진 노드인 노드를 찾아 `next`를 `next.next`로 바꿔줘야 한다.

### ‼️ **[돌발 퀴즈 3]** 여러분의 삶에서 즉시 해야 할 2가지 일과 최대한 지연시켜야 할 2가지 일을 생각해보자.

→ 즉시 해야할 일(다이어트, 💩 ...), 최대한 지연시켜야 할 일(테트리스..테친놈됬습니다 책임져요 쿠킴, 놀 궁리)

### ‼️ **[돌발 퀴즈 4]** 여러분이 자바 컴파일러를 만든다고 가정해보자. 클래스 사이의 상속 관계를 트리로 나타낸다면 부모 포인터 트리와 자식 포인터 트리 중 어느 방식을 사용하겠는가?

→ 부모 포인터 트리. 상위 클래스는 하위 클래스의 정보를 몰라도 되지만, 하위 클래스는 상위 클래스의 정보를 알아야 하므로 부모 포인터 트리 방식을 사용할 것 같다.

### [연습 문제 1] 3장에서 살펴본 3가지 수조 구현에 `groupSize` 메서드를 추가하자. 단 필드를 추가하거나 기존 메서드를 변경하지 않는다.

1. 3가지 경우에 최악의 경우 점근적 복잡도는 어떠한가?

   → O(1), O(n), O(n)

   - speed1 : O(1)
     ```java
     public int groupSize() {
         return group.members.size();
     }
     ```
   - speed2 : O(n)
     ```java
     public int groupSize() {
         int groupSize = 1;
         SpeedContainer2 current = this;
         while (current.next != this) {
             groupSize++;
             current = current.next;
         }
         return groupSize;
     }
     ```
   - speed3 : O(n)
     ```java
     public int groupSize() {
         return findRootAndCompress().size;
     }
     ```

   ⇒ O(1), O(n), O(logN)

2. 다른 메서드의 점근적 복잡도를 증가시키지 않고 `groupSize`가 상수 시간에 수행되도록 `Speed2`를 수정할 수 있는가?

   → `amount` 처럼 수조의 개수를 카운팅하는 필드를 추가하면 상수 시간에 수행될 수 있다.

### [연습 문제 2] 3장에서 살펴본 3가지 수조 구현에 `flush` 메서드를 추가하자. 단 기존 메서드를 변경하지 않는다.

1. 3가지 경우에 최악의 경우 점근적 복잡도는 어떠한가?

   → O(1), O(n), O(n)

   - speed1 : O(1)
     ```java
     public void flush() {
         group.amountPerContainer = 0;
     }
     ```
   - speed2 : O(n)
     ```java
     public void flush() {
         SpeedContainer2 current = this;
         while (current.next != this) {
             current.amount = 0;
             current = current.next;
         }
     }
     ```
   - speed3 : O(n)
     ```java
     public void flush() {
         findRootAndCompress().amount = 0;
     }
     ```

   ⇒ O(1), O(n), O(logN)

2. 다른 메서드의 점근적 복잡도를 증가시키지 않고 `flush`가 상수 시간에 수행되도록 `Speed2`를 수정할 수 있는가?

   → 없다.

### [연습문제 3] 미니 프로젝트

전기가 흐르는 그리드 `Grid`와 그리드로부터 전력을 공급받는 전자창치 `Appliance` 클래스를 만들고 다음과 같은 기능을 제공하자.

- 그리드는 제공 가능한 최대 전력, 전자장치는 소비 전력을 특징으로 포함
- `plugInto` 메서드를 이용해 전자장치를 그리드에 연결
  - 전자장치를 다른 그리드에 연결하면 자동으로 기존에 연결된 그리드와 연결을 끊는다.
- `on`, `off` 메서드를 이용해 전자장치를 키고 끌 수 있다
  - 새로 생성되는 전자창지는 꺼진 상태
  - 과부하가 걸린 그리드의 전자장치를 켜면 `on` 메서드는 예외를 던짐
- `residualPower` 메서드는 그리드에 남아 있는 전력량을 리턴

❓ 모든 메서드가 상수 시간에 실행되도록 두 클래스를 설계할 수 있는가?

→ 🙆‍♀️

### [연습문제 4]

1. `ArrayList`에서 배열이 가득 찰 때마다 용량을 10%씩 증가시킨다면 `add`의 분할상환 복잡도는 여전히 상수 시간인가?

   → 🙄

   ⇒ yes. 10%는 물론 어떠한 비율로 확장하더라도 삽입 연산의 분할상환 복잡도는 상수 시간이다. 적절한 비율을 선택하면 시간과 공간 사이의 균형을 맞출 수 있다. 비율이 낮을수록 상수는 커지고 시간 효율성은 떨어진다. 반면 `ArrayList`의 용량이 실제 크기와 비슷해질수록 공간을 절약할 수 있다.

2. 이렇게 하면 배열의 용량을 확장하는 일이 더 자주 벌어진다. 정확하게 얼마나 자주 확장을 수행하는가?

   → 🤮

   ⇒ 10%씩 확장할 때가 50%씩 확장할 때보다 4.25배 많은 재할당을 수행한다.
