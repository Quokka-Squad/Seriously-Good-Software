# 4장\_소중한 메모리: 공간 효율성

### ✔️ check point

- 공간 효율적인 클래스 작성
- 배열과 리스트, set을 포함한 일반적인 자료 구조 사이의 메모리 요구 사항 비교
- 성능과 메모리 사용량 사이의 기회비용 측정
- 메모리 지역성을 활용한 성능 향상

---

## 수조 예제 공간 효율성 개선 아이디어

### 공간을 절약하는 데이터 타입으로 변경

- `double` → `float`
- `Set` → `ArrayList`
  - `ArrayList` : 일반적인 배열을 둘러싼 얇은 wrapper일 뿐이므로 요소 하나당 4바이트 사용
    - 내부적으로 배열과 특별한 용도의 2~3개 필드로 구현
    - `size`(크기) : `ArrayList`에 실제로 저장된 요소의 개수
    - `capacity`(용량) : 크기와 별개로 내부적인 배열의 길이
    - `ArrayList`의 메모리 소모량 → `40 + 4n`
      - 객체 표준 헤더 `12byte`
      - 리스트에 수행된 구조적 수정(삽입과 삭제) 횟수를 저장하는 정수 필드 `4byte`
      - 크기를 저장하는 정수 필드 `4byte`
      - 배열을 가리키는 참조 `4byte`
      - 배열 객체의 표준 헤더 `12byte`
      - array length를 저장하는 정수 필드 `4byte`
      - 배열 한 칸마다 `4byte`
  - 다른 수조에 연결되지 않은 수조가 많다면, 정말 필요한 시점에서 리스트를 초기화(`lazy initialization` 지연 초기화)
  - 중복된 요소를 자동으로 걸러주는 기능이 사라지므로 주의
- 메모리 절감효과 대신 치뤄야 할 성능상의 비용은 없지만 가독성이 낮아짐
- 기본 타입만 저장할 때는 `GNU Trove`를 비롯한 여러 라이브러리에서 값에 상응하는 클래스를 랩핑하는 부담을 없앤 특화된 `set`과 `map` 구현 제공

### 일반 배열을 이용해 더 절약

- `ArrayList` → `Container[]`
  - 일반 배열의 메모리 소모량 → `16 + 4n`
  - `ArrayList` 사용에 비해 공간 절약이 두드러지지 않지만 배열 길이를 그룹 크기에 딱 맞게 관리했기 때문에 메모리가 많이 절약됨(`ArrayList`는 배열 용량을 느슨하게 관리)
  - 자바 API의 클래스를 사용하지 않는다는 점에서 완전하게 자기포함적(self-contained)
    - 자바9에서 모듈(module)시스템이 도입되면서 실행 환경을 제한할 수 있게 됬는데 이런 환경에서도 잘 동작
- 일반적인 컬렉션의 메모리 요구 사항(내부적인 `size`와 `capacity`가 같다고 가정)
  | 종류 | 크기(객체 자체) | 크기(요소 하나당) |
  | ---------- |:---------------:|:-----------------:|
  | array | 16 | 4 |
  | ArrayList | 40 | 4 |
  | LinkedList | 24 | 24 |
  | HashSet | 52 | 32 |
- `ArrayList`는 높은 추상화 수준을 제공해 코드 가독성을 높이는 데 도움을 준다. (+ 제네릭 지원)
- `HashSet`은 삽입되는 모든 요소를 새로운 객체로 감싸기 때문에 체급이 다르지만 다음과 같은 독보적인 기능을 최적의 시간에 제공
  - 멤버십 쿼리(membership query)를 상수 시간에 제공(`contains`)
  - 중복된 요소의 삽입을 상수 시간으로 방지(`add`)
  - 임의의 요소를 상수 시간에 제거(`remove`)
- 프로그램의 메모리 제약이 심하지 않다면 일반적으로 `HashSet`이 메모리 사용량보다 큰 보상을 줄 것

### 객체를 제거

- 객체를 사용하지 않고 클라이언트가 각 수조를 식별하려면? → `handle`(수조를 유일하게 식별하는데 필요한 정보)를 클라이언트에게 제공
- 메모리 오버헤더를 동반하지 않는 대안적인 핸들 → **정수 ID**(수조를 객체로 저장하는 대신 클라이언트가 정수 ID로 수조를 식별)
- 정수 ID로 인덱싱되는 공간 효율성 +높은 자료구조(배열)에 필요한 정보(물의 양과 수조 간 연결) 저장
- 객체지향 원칙에 반하며 완전히 공간 제약에 초점
- 배열을 사용하면 캐시 지역성(cache locality) 덕분에 시간 효율성도 높일 수 있다.
- 자바에서 캐시 지역성을 활용하려면 일반 배열이나 배열을 바탕으로 한 클래스를 사용해야 함
- 제네릭 클래스는 참조만 저장하므로 캐시 지역성도 참조 자체에 국한되며 참조가 가리키는 데이터(객체)에는 적용되지 않는다. (참조 차제는 이웃한 메모리 위치에 저장되지만 실제 정수 값은 X)
  - `GNU Trove`와 같은 외부 라이브러리를 사용하면 기본 배열의 캐시 지역성과 `ArrayList`의 자동 크기 조정을 비롯한 편의 기능을 모두 누릴 수 있음.
- 클래스의 불변 조건 : 클래스의 메서드가 실행되는 동안을 제외하고 항상 성립해야 하는 조건
  - 클래스의 모든 메서드는 시작 시점에 불변 조건이 참이라는 사실에 의존, 끝난 후에는 불변 조건이 계속 성립하는 것을 보장해야 함

### 배열 하나로 연결과 물의 양을 한번에 관리

- 수조 하나당 4바이트를 사용하는 대가로 시간 복잡도를 희생
- 연결 리스트로 저장된 것처럼 같은 그룹에 속하는 다음 수조의 인덱스를 배열 요소로 저장(양수)
- 고립된 수조이거나 그룹의 마지막 수조여서 다음 수조가 존재하지 않는다면 수조에 담긴 물의 양을 저장(음수)
  - 요소 값이 0인 경우 인덱스와 물의 양 모두로 해석될 수 있지만 `float` 타입은 양의 0과 음의 0을 구별하지 않는다 → 0은 물의 양으로 해석하고 다음 수조의 인덱스에는 모든 인덱스에 1을 더해(편향 bias) 0을 사용하지 않는다.

### 결론

- **최적의 선택은 풀어야 할 문제의 상황에 따라 달라진다**
- 객체로 인한 오버헤드 한계를 넘으려면 객체를 포기하여 가독성과 유지보수성을 희생시켜야 함
- 대부분의 프로그래밍 환경에서는 이러한 기법을 꺼리지만 임베디드 시스템과 같이 메모리 제약이 심하거나 매우 큰 데이터를 메모리에 올려야할 때 유용
- 시간 효율성 ↔  공간 효율성 트레이드 오프 발생

## 캐시 지역성(cache locality)

- 프로세스가 시간/공간적으로 유사한 데이터를 집중적으로 참조하는 성질
- 시간적(Temporal) 지역성
  - 최근 사용된 데이터의 재 이용률이 높음
  - Loop, Sub Routine
- 공간적(Spatial) 지역성
  - 메모리 상 인접 데이터의 재 이용률이 높음
  - ex) 데이터베이스 파티션
- 순차적(Sequential) 지역성 ✔️
  - 메모리에 저장된 순서대로 이용된 가능성이 높음
  - ex) 배열
- 메모리상에서 가까운 곳에 있는 데이터에 접근(ex. 배열)하는 편이 무작위로 흩어진 데이터(ex. 연결 리스트)에 접근하는 것보다 빠르다.
- 메모리와 CPU 사이의 성능차를 줄여주는 메모리 버퍼인 CPU 캐시의 구조(소량의 이웃한 데이터를 저장) 때문

[캐시 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%BA%90%EC%8B%9C)

[캐시 지역성(Locality)](https://bibimnews.com/entry/%EC%BA%90%EC%8B%9C-%EC%A7%80%EC%97%AD%EC%84%B1Locality)

## 메모리 계층 구조

- 현대적인 컴퓨터는 여러 레벨의 계층 구조로 구성되는데, 아래 레벨로 갈수록 커지고 속도는 느려진다.
- CPI 레지스터 → 캐시 → 메모리 → 하드 디스크

[메모리 계층 구조 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0)

## 팩터리 메서드(factory method)

- 클래스의 새로운 인스턴스를 리턴하는 메서드
- 생성자와 비교한 팩터리 메서드의 장점
  - 특정 클래스의 객체는 물론 리턴 타입의 하위 타입을 모두 리턴할 수 있다.
    - ex) `EnumSet`
  - 실제로 새로 생성된 객체를 리턴할 필요가 없다.
    - 객체가 불변이라면 객체를 캐싱하거나 재사용해도 문제가 없다.
    - ex) `Integer.valueOf` - 기본 정수를 `Integer` 객체로 감싸는데 새로운 객체를 리턴할 수도 안 할 수도 있다.
- `FACTORY METHOD` : GoF가 정의한 디자인 패턴 중 하나. 팩터리 메서드를 지칭하지만 특별한 경우에 국한
  - 클라이언트에게 객체를 제공하되 서브클래스에서 객체의 실제 타입을 정할 수 있다.
  - ex) `Iterable`의 `iterator()`

## 클래스를 인스턴스화 불가능하게 만드는 방법

- 클래스가 아닌 인터페이스로 선언
- 클래스를 `abstract`로 선언
- 유일한 생성자로 `private` 생성자 만들기
  - JDK에서도 인스턴스화 불가능 클래스를 만들 때 이 방법 사용(`Math` 등과 같은 유틸리티 클래스)
  - 이러한 클래스는 상태(변경 가능한 필드)를 포함하지 않고 편의 기능을 제공하는 역할만 한다.
