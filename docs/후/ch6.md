# 6장\_나를 속여봐: 테스트를 이용한 신뢰성 향상

### **✔️ check point**

- 단위 테스트 슈트 설계
- 입력 커버리지 기준 적용
- 코드 커버리지 측정
- 코드 테스트 용이성 평가와 개선

## 테스트의 기본적 개념

- 소트트웨어 업계에서 테스트 : 주요 검증 활동
- 최대한 많은 버그를 찾아내 제거하는 것이 목표, 이를 바탕으로 프로그램의 정확성과 견고성을 개선할 수 있다.
  - 복잡한 프로그램에 버그가 발생하지 않을리 없으며, 실제 사용 시 필연적으로 발생할 큰 결함을 테스트로 찾아내야 함

### 테스트 커버리지

- 커버리지 : 테스트 설계의 중요 주제 중 하나로 여러 의미로 해석됨
  - 테스트가 시스템의 다른 부분을 시뮬레이션 할 수 있는 정도
  - 코드 기반(code-based) 커버리지 : 주어진 테스트 집합에서 한번이라도 실행되는 소스 코드의 비율.
    - 화이트 박스 테스트(whitebox test) : 테스트할 소프트웨어(SUT, Software Under Test)의 내부 관련 지식과 소스 코드를 알고 있다고 가정
  - 입력 기반(input-based) 커버리지 : SUT의 내부는 무시하고 API에 집중. 가능하면 입력의 전체 집합을 분석하고 전체를 대표하는 더 작은 값의 집합을 도출.
    - 블랙 박스 테스트(blackbox text) : SUT의 소스 코드에 독립적
  - 두 커버리지는 서로 보완하는 관계
- 커버리지를 고려한 체계적인 방법을 채용함으로써 테스트에서 큰 결함을 모두 발견할 가능성을 높일 수 있다.
- 입력 기반 커버리지를 목표로 삼고 테스트 계획 자체를 검증하는 방법으로 코드 기반 커버리지를 활용

### 테스트와 계약에 의한 설계

- 사전 조건을 검사하고 적절한 패널티를 부여하는 것은 방어적 프로그래밍의 기본(모범 사례)
- 테스트는 이를 대체하기보다 오히려 강화하는 것
- 실전에서 테스트를 훨씬 더 일반적으로 활용하는 이유는 다음과 같다.
  - 테스트를 이용하면 불변 조건과 사후 조건 검사를 클래스 밖으로 옮길 수 있다. 이렇게 하면 클래스를 작고 단순하게 유지하는 것은 물론 책임 경계가 명확해지고 조직적 측면에서 개발과 테스트를 다른 팀에 맡길 수 있다.
  - 주어진 메서드를 다양한 입력으로 호출해보는 체계적인 방법(테스트 계획)이 없으면 프로그램 개발과 배포의 어느 단계에서든 버그를 찾아내지 못한다. 테스트를 하면 이 과정을 책임져야 하며 커버리지 척도를 바탕으로 SUT의 정확성과 신뢰도를 가늠할 수 있다.

### 테스트 용이성

- 입력을 제공할 수 있어야 한다. (제어 가능성controllabiltity - 테스트할 단위(UUT, Unit Under Test)에 임의의 입력을 제공하는 것이 얼마나 쉬운지 나타냄)
  - 제어 가능성이 낮은 단위를 테스트하려면 커뮤니케이션 채널의 다른 쪽 끝을 시뮬레이션하는 인프라스트럭처가 필요하다.
- 입력의 효과를 관측할 수 있어야 한다. (관측 가능성observability)
  - 메서드 호출에 대한 즉각적인 피드백을 얻을 수 있도록 값을 리턴하도록 메서드 설계
  - 더 많은 정보를 노출할 수록 테스
- 의존성으로부터 UUT를 고립시켜야 한다.
  - UUT가 다른 단위에 의존적이라면(메서드 안에서 다른 클래스의 메서드를 호출한다면) 테스트에서 찾아낸 결함이 UUT에서 비롯된 것인지 의존하는 단위 중 하나에서 비롯된 것인지 알 수 없기 때문에
  - 이런 문제를 완화하기 위해 의심하지 않아도 될 만큼 간단한 가짜 객체로 실제 의존성을 교체하는 모킹(moking)이나 스터빙(stubbing) 기법을 이용
    - `Mockito`, `Powermock` 등의 라이브러리를 이용하면 이러한 작업을 자동화
  - 의존성 주입으로 테스트 용이성을 높일 수 있다
    - 테스트할 클래스에서 다른 타입의 객체를 만든다면, 의존성 주입으로 클라이언트가 해당 객체를 외부에서 전달하도록 함
    - 단점
      - 클래스의 구현을 노출함으로써 캡슐화 위반 - 테스트 용이성 향상과 캡슐화 훼손 사이의 균형을 맞춰야 함
      - 호출자에게 큰 부담을 줌 - 클라이언트가 오류를 일으킬 가능성이 높아짐
    - 의존성 주입을 바닥부터 구현하기보다 이를 목적으로 하는 프레임워크를 이용하는 것이 좋음

### JUnit

- 자바의 표준 단위 테스트 프레임워크로 테스트 슈트를 작성하고 실행하는 기능을 무료 오픈소스로 제공

### JaCoCo

- 테스트의 코드 커버리지를 확인할 수 있는 오픈소스 자바 코드 커버리지 프레임워크
- 자바 에이전트(Java Agent)를 이용해 런타임 정보를 수집. 자바 에이전트는 JVM에서 백그라운드로 실행하는데 프로그램 실행을 조사하거나 조작할 수 있다.
- 도구를 이용해 정보를 수집한 후에는 HTML을 비롯한 여러 가지 형태로 리포트를 얻을 수 있다.
- 다음과 같은 여러가지 코드 커버리지 기준 측정 가능

  - 명령어 커버리지(instruction coverage) : 실행된 바이트코드 명령어의 비율
  - 행 커버리지(line coverage) : 실행된 자바 코드 행의 비율
  - 분기 커버리지(branch coverage) : 실행된 조건 분기의 비율

- [Gradle 프로젝트에 JaCoCo 설정하기 | 우아한형제들 기술블로그](https://techblog.woowahan.com/2661/)

## 수조 테스트하기

### 테스트 초기화하기

- `JUnit`의 `@Before`을 부여하면 매번 테스트를 실행하기 전에 해당 메서드를 실행. 코드 중복을 피할 수 있다.
- 여러 테스트가 공유하는 객체 → 테스트 비품(fixture)

### 입력 도메인 모델링(input domain modeling)

- 테스트할 메서드에 넘겨줄 입력 값을 체계적으로 선택하기 위한 표준적인 블랙박스 기법
- 입력 도메인 모델을 이용하면 메서드에 적합한 의미 있는 제한된 입력 값 집합을 얻을 수 있다.

1. 서로 연관된 입력의 특성을 몇 가지로 정의
   - 특성 - 가능한 입력 값 전체의 집합을 유한한 유형(블록)으로 분할하는 특징. 입력의 종류나 메서드 계약을 바탕으로 도출할 수 있다.
     - ex) 정수 입력 : 음수, 0, 양수 세 블록으로 나눌 수 있음
2. 이러한 특성을 조합해 유한한 집합을 만든다.
3. 각 조합에서 선택한 입력 값으로 테스트를 구성. 이렇게 주어진 입력으로 메서드를 실행하고 계약에 따라 기대했던 결과 값과 비교(예외를 던지는 것도 기대했던 결과에 포함)

### 특성 선택하기

1. 데이터 타입을 고려

   | 타입            | 특성             | 블록                                               |
   | --------------- | ---------------- | -------------------------------------------------- |
   | int/long        | 부호             | {음수, 0, 양수}                                    |
   | float/double    | 부호와 특수한 값 | {음수, 0, 양수, 무한대, NaN}                       |
   | String          | 길이             | {null, 빈 문자열, 비어 있지 않은 문자열}           |
   | 배열이나 컬렉션 | 크기             | {null, 빈 배열/컬렉션, 비어 있지 않은 배열/컬렉션} |

   - 일반적인 특성일 뿐 훨씬 다양하고 흥미로운 표준 특성을 활용하는 것이 좋음
   - ex) 문자열 - 희귀한 문자와 알파벳의 입력

2. 테스트할 메서드의 계약을 이용

   | 이름 | 특성                                   | 블록                                       |
   | ---- | -------------------------------------- | ------------------------------------------ |
   | C1   | 이 수조가 적어도 한 수조에 연결됨      | {true, false}                              |
   | C2   | 인자와 그룹에 담긴 물의 양 사이의 관계 | {양수, 0, 유효한 음수, 유효하지 않은 음수} |

   - 어떠한 특성 값이 사전 조건을 위반해 예외가 발생하면 일반적으로 모든 경우를 테스트하지 않고 한 번만 테스트해도 충분하다.

### 블록 조합 선택하기

- 최대한 많은 결함을 찾아내려면 서로 다른 특성으로 나눠진 블록의 조합 일부나 전체를 테스트
- 블록 조합 전체를 테스트 → 전체 조합 커버리지(All Combinations Coverage)
- 입력 커버리지 기준
  - 개별 선택 커버리지(Each Choice Coverage) : 각 특성에서 파생된 모든 블록이 적어도 한 테스트에서 사용돼야 함
  - 기반 선택 커버리지(Base Choice Coverage) : 기반이 되는 블록 조합을 선택한 후 어떠한 특성의 모든 값이 등장할 때까지 해당 특성 하나만 변경

### 실제 값 선택하기

- 각 특성 조합에 대한 특정 값을 선택

## 결론

- 입력 도메인 모델 방법론을 이용하면 의미 있는 테스트 입력을 찾을 수 있다.
- 여러 파라미터의 입력 값을 어떻게 조합하느냐에 따라 테스트 수와 커버리지 수준이 달라진다.
- 입력 커버리지와 코드 커버리지를 바탕으로 테스트 커버리지를 평가할 수 있다.
- 메서드의 피드백을 추가해 테스트 용이성을 개선할 수 있다.
- 의존성 주입을 이용하면 테스트할 클래스의 의존성을 간단하게 대체해 해당 클래스를 고립시킬 수 있다.

## **퀴즈 & 연습 문제**

### ‼️ **[돌발 퀴즈 1] 메서드 계약의 어느 부분이 메서드 테스트와 관련 있는가?**

→ 패널티와 사후 조건 부분

⇒ 모든 부분.

- 사후 조건은 메서드가 의도하는 효과를 기술하므로 테스트가 검사해야 할 어셔션을 짚어준다.
- 대부분의 단위 테스트는 대상 메서드에 적법한 입력을 제공한 후 출력이 사후 조건을 준수하는지 검사
- 다른 유형의 테스트는 올바르지 않은 입력을 제공한 후 메서드가 계약에 명시된 패널티에 따라 반응하는지 검사

### ‼️ **[돌발 퀴즈 2] 날짜를 표현하는 데이터 타입에는 어떠한 특성이 있을까?**

→ lengthOfMonth

⇒ 윤년{true, false}, 달의 길이{28, 29, 30, 31}, 달에 속하는 일{첫날, 중간, 마지막 날}

### ‼️ **[돌발 퀴즈 3] 독립적인 세 특성이 존재하고 각 특성에 따른 블록 개수가 n1, n2, n3이라면 전체 조합 커버리지를 달성하는 데 몇 개의 테스트가 필요한가? 개별 선택 커버리지와 기반 선택 커버리지에는 몇 개의 테스트가 필요한가?**

- 전체 조합 : n1 _ n2 _ n3
- 개별 선택 : 몰라
- 기반 선택 : 몰라

⇒ 각 커버리지를 달성하는 데 필요한 테스트 개수는 다음과 같다.

- 전체 조합 : n1 _ n2 _ n3
- 개별 선택 : max(n1, n2, n3)
- 기반 선택 : 1 + (n1 - 1) + (n2 - 1) + (n3 - 1) → n1 + n2 + n3 - 2

### ‼️ **[돌발 퀴즈 4] 프로그램이 `assert` 구문을 포함한다면 테스트할 때 어서션을 활성화해야할까, 비활성화해야 할까?**

→ 실제 배포되어 실행되는 코드로 테스트 해야하므로 비활성화

⇒ 둘 다. 우선 소프트웨어가 실제 배포 환경과 똑같이 작동하도록 어서션 없이 테스트 하고, 실패한 테스트가 있으면 어서셜을 활성화해 결함을 찾는 과정에서 도움을 얻을 수 있음.

### ‼️ **[돌발 퀴즈 5] 파일에서 수조 객체를 읽는(역직렬화) 정적 메서드를 Container 클래스에 추가하면 테스트 용이성에 어떠한 영향을 미칠까?**

→ 제어 가능성이 낮아져 테스트 용이성이 낮아진다.

⇒ 역직렬화를 수행하는 메서드는 파일에서 복잡한 입력을 받아들이므로 테스트 용이성을 떨어뜨린다.

### ‼️ **[돌발 퀴즈 6] 현재 수조에 직/간접적으로 연결된 수조의 개수를 리턴하는 public 메서드를 Container 클래스에 추가하면 테스트 용이성에 어떠한 영향을 미칠까?**

→ 관측 가능성이 높아져 테스트 용이성이 높아진다.

⇒ 일반적으로 읽기 전용 메서드는 안전하고(문제의 소지가 적고) 객체의 상태를 관찰할 수 있는 수단을 제공하므로 테스트 용이성에 도움을 준다. 결과적으로 `groupSize` 메서드를 추가함으로써 테스트 용이성이 개선된다.

### [연습문제 1]

1. 다음과 같은 계약을 따르는 `getDivisors` 메서드의 테스트 계획을 수립해 실행하라.
   - 사전 조건 : 메서드의 유일한 파라미터는 정수 n이다.
   - 사후 조건 : 메서드는 n의 모든 약수를 `Integer`의 `List`에 담아 리턴한다. `n==0`이면 빈 리스트를 리턴한다. `n`이 음수이면 그 반대 부호를 취한 후의 약수를 리턴한다.
   - 패널티 : 없다.

### [연습문제 2]

입력 도메인 모델 방법론을 이용해 `String` 클래스의 다음 메서드를 위한 테스트 계획을 수립해 실행하라.

`public int indexOf(int ch, int fromIndex)`

### [연습문제 3]

1. 입력 도메인 모델 방법론을 이용해 `interleaveLists` 메서드를 위한 테스트 계획을 수립해 실행하라. 메서드 계약은 다음과 같다.
   - 사전 조건 : 메서드는 같은 길이의 `List` 2개를 인자로 받는다.
   - 사후 조건 : 메서드는 두 리스트의 요소가 번갈아 저장된 새로운 `List`를 리턴한다.
   - 패널티 : 주어진 두 리스트 중 하나가 `null`이면 메서드는 NPE를 던진다. 두 리스트의 길이가 다르면 IAE를 던진다.
2. 수립한 테스트 계획의 코드 커버리지를 측정하자. 수동으로 측정하거나 커버리지 도구를 이용하자.

### [연습문제 4]

크기가 동적으로 커지는 T타입 집합에 대한 인기도 컨테스트를 표현하는 제네릭 인터페이스 `PopularityContext<T>`의 테스트 용이성을 개선하자. 인터페이스는 다음과 같은 메서드를 포함한다.

- `void addContestant(T contestant)` : 새로운 참가자를 추가한다. 중복된 참가자는 무시한다.
- `void voteFor(T contestant)` : 주어진 참가자에게 투표한다. 해당 참가자가 존재하지 않으면 IAE를 던진다.
- `T getMostVoted()` : 가장 많이 득표한 참가자를 리턴한다. 컨테스트가 비어 있으면 ISE를 던진다.
