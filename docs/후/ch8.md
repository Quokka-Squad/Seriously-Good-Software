# 8장\_스레드 안정성

### **✔️ check point**

- 교착 상태(deadlock)와 경합 조건 인지하고 회피하기
- 명시적인 락 사용
- 락-프리(lock-free) 동기화 사용
- 클래스를 불변으로 설계하기

## 스레드 안정성 달성의 어려움

- 스레드 안정성을 방해하는 요소 - **경합 조건**, **교착 상태**
  - 경합 조건 : 일반적으로 동기화를 너무 수행하지 않아서 발생. (서로 다른 스레드에서 동시에 수행한 두 연산 때문에 적어도 한 연산의 사후 조건이 깨질 때)
    - ex) 두 스레드가 증가 메서드를 거의 동시에 호출한다면 두 번 증가하는 대신 한 번만 증가할 수 있음
    - 뮤텍스(mutex)와 모니터를 비롯한 동기화 요소를 사용하면 경합 조건을 해결 가능
    - 자바의 `synchronized` 키워드는 기본적인 동기화 메커니즘을 구성
  - 교착 상태 : 일반적으로 동기화를 지나치게 했을 때 발생 (무분별한 동기화 때문에 둘 이상의 스레드가 서로 순환하는 형태로 영원히 기다리게 될 때)
  - `synchronized` 블록과 명시적 락(explicit lock)을 비롯한 저수준 동기화 요소를 이용해 회피
- 자바의 멀티스레드 지원
  - 실행자(excutor) 서비스(JAVA5) : 사용자 정의 작업을 수행하는 적절한 수의 스레드를 생성하고 관리하는 몇 가지 클래스와 인터페이스. `java.util.concurrent` - `ExecutorService`, `Executors`
  - 포크-조인(fork-join) 프레임워크(JAVA7) : 복잡한 계산을 여러 스레드로 분산(fork)하고, 그 결과를 한 값으로 병합(join)
  - 병렬스트림(JAVA8) : 순차적인 데이터 제공자에 복수의 단일 연산을 적용하는 강력한 라이브러리. - `Stream`에서 시작

## 동시성 레벨

| 레벨        | 동시 허용 연산     | 락의 개수                   |
| ----------- | ------------------ | --------------------------- |
| 클래스 레벨 | 다른 클래스에 접근 | 클래스 당 락 하나           |
| 객체 레벨   | 다른 객체에 접근   | 객체 당 락 하나             |
| 메서드 레벨 | 다른 메서드에 접근 | 각 객체의 메서드 당 락 하나 |
| 무제한      | 모든 연산          | 락 필요 없음                |

## 교착 상태 다루기

- 원자적 락 시퀀스(atomic lock sequence) - 허용하는 동시성 정도를 제약해 교착 상태를 방지
  - 두 시퀀스를 동시에 수행할 수 없게 막는 또 다른 락이 필요
  - 락 획득을 요청하는 시퀀스는 다른 시퀀스가 시행되는 동안 시작할 수 없음
  - 필요한 락 중 하나가 잠긴 상태라면 전역 락도 잠겨 있어 다른 시퀀스가 시작할 수 없고 교착 상태의 위험도 사라짐
  - but, 전혀 다른 락 집합을 획득하려는 시퀀스스도 다른 시퀀스가 완료될 대까지 시작할 수 없음
- 순서 있는 락 시퀀스(ordered lock sequence)
  - 모니터 사이의 전역적인 순서를 정해 모든 스레드가 알 수 있게 하고 모든 스레드는 이 순서대로 락을 획득하게 하는 방법
  - 각 그룹에 유일한 정수 ID를 할당(`AtomicInteger`, `Object.hashCode`를 이용)하여 전역 시퀀스 생성
    - hashCode는 반드시 유일한 식별자라는 것을 보장 X(두 객체가 같은 해시 코드를 가질 수도 있으므로)

---

### 중간 생략... 강해져서 돌아오자

---

## 불변성

- 모든 스레드 동기화 문제 → 한 스레드가 공유된 메모리 영역을 읽거나 쓰는 동안 다른 스레드가 해당 영역에 쓰기를 수행할 때 발생
- 모든 공유 객체를 불변 객체로 만들어 스레드 안정성 달성
  - 객체를 초기화하고 공유한 후에는 어떠한 스레드도 객체를 수정할 수 없으므로 위험한 상황이 발생할 수 없다.
- 어떠한 클래스가 불변이기 위해서는 모든 필드를 final로 선언해야 하고 참조하는 다른 모든 클래스도 불변이여야 한다.
- 복사(copy-on-write) 기법
  - 가장 간단한 방법이지만 일반적으로 가장 효율적인 방법은 아님
- 변경 연산을 수행할 때 전혀 새로운 사본을 만드는 대신 이전 객체에서 최대한 많은 부분을 재활용하는 것
  - 더 세련된 방식
- 영속적 컬렉션을 제공하는 몇 가지 자바 라이브러리를 이용하면 수정된 복사본이 원래 객체와 일부 데이터를 공유함으로써 일반적인 쓰기를 할 때 복사와 비교해 시간과 공각을 절양할 수 있다.
  - ex) `PCollections`

## 결론

- 합리적인 동시성 정책은 스레드 안전성에 지극히 필수적이다.
- 스레드 안전성의 가장 큰 적은 경합 조건과 교착 상태다.
- 전역 락이나 순서 있는 락 정책을 이용해 교착 상태를 피할 수 있다.
- 암묵적 락과 달리 명시적 락은 원하는 순서대로 획득하고 해제할 수 있다.
- 불변성은 스레드 안전성의 대안적 방법이다.

## 퀴즈 & 연습 문제

### ‼️ **[돌발 퀴즈 1] 클래스의 사용자와 구현자 중 어느 쪽이 동시성 정책을 고려해야 할까?**

→ 구현자

⇒ 클래스의 사용자는 클래스가 스레드 안전한지 여부만 알면 된다. 나머지 동시성 정책은 구현자 몫이다.

### ‼️ **[돌발 퀴즈 2] 각 스레드가 한 번에 하나의 락만 획득할 때도 교착 상태가 발생할 수 있을까?**

→ 강해져서

⇒ 돌아오자.

### ‼️ **[돌발 퀴즈 3] `synchronized` 블록 안에서 예외가 발생하면 어떻게 될까?** `ReentrantLock`을 소유한 스레드가 예외를 던지면 어떻게 될까?

→ 강해져서

⇒ 돌아오자.

### ‼️ **[돌발 퀴즈 4] 순서 있는 락 기법이 교착 상태를 방지하는 이유는 무엇인가?**

→ 순서대로 락을 획득하므로(?)

### ‼️ **[돌발 퀴즈 5] 불변 클래스가 자연적으로 스레드 안전한 이유는 무엇인가?**

→ 수정이 불가능 하기 때문에

⇒ 불변 클래스는 자동으로 스레드 안전하다. 객체는 읽기만 가능하고 여러 스레드에서 동시에 읽더라도 안정성에 문제가 없기 때문이다. 새로운 객체를 생성하는 메서드는 스택에 있는 가변 지역 변수를 사용하므로 다른 스레드와 데이터를 공유하지 않는다.
