# 5장\_모니터링을 이용한 신뢰성 향상

### **✔️ check point**

- 계약 형태로 메서드 명세 작성하기
- 런타임에 계약 준수 강제하기
- Assertion 사용하기
- 사후 조건의 가벼운 대안으로서 클래스 불변 조건 확인하기

---

> 견고성은 모든 실패의 원인을 피하도록 시스템을 설계하는 것이 아니라 실패할 경우 시스템이 우아하게 반응하는 것

## 계약에 의한 설계

- 계약에 의한 설계 방법론에서는 소프트웨어의 구성품, 특히 메서드마다 계약을 부과한다.
- 메서드 계약은 다음과 같은 내용으로 이뤄진다.
  - 사전 조건(precondition)
  - 사후 조건(postcondition)
  - 패널티(penalty)

### 사전 조건(precondition)

- 메서드가 올바로 기능하는 데 필요한 요구 사항을 기술
  - 파라미터의 유효한 값
  - (인스턴스 메서드의 경우) 현재 객체의 유효한 상태
  - ex) 제곱근을 구하는 메서드의 사전 조건에 따르면 주어진 인자는 음수가 아니여야 함
- 호출할 메서드의 사전 조건을 지키는 것은 호출자(호출하는 쪽)의 책임
- 사전 조건은 호출자가 완벽하게 제어할 수 있는 성질의 조건만 포함해야 함
  - ex) 파일 이름을 인자로 받는 메서드 - 주어진 파일이 존재해야 한다는 조건은 사전 조건에 포함될 수 없음(파일이 존재하는지 호출자가 100% 확신할 수 없음)
  - 메서드에서 예외를 던질 수 있지만 그 예외는 호출자의 처리를 강제하는 `checked exception`이여야 함

### 사후 조건(postcondition)

- 메서드 호출로 야기되는 모든 변화를 기술
  - 리턴 값(메서드의 주요 효과)
  - 입력으로 주어진 인자의 값
  - 객체의 이전 상태(메서드의 동작에 영향을 미치는 입력)
  - 객체의 이후 상태(메서드로 인한 결과)
  - `System.out.println` 호출 처럼 전역적으로 접근 가능한 객체나 정적 메서드로 인한 side effect
- 잘 설계된 클래스라면 메서드 호출 후의 변화는 해당 객체에만 한정돼야 하지만 항상 그런 것은 아님
  - ex) 수조 예제의 `connectTo` : 의도한 효과를 달성하기 위해 여러 수조의 상태를 변경
- 패널티도 같이 명시해야 함
- 메서드 실행 전후의 객체 상태를 비교하므로 동적 일관성 규칙(dynamic consistency rule)

### 패널티(penalty)

- 호출자가 사전 조건을 어겼을 때 발생하는 일
- 자바에서 주로 사용하는 패널티는 `unchecked exception`을 던지는 것

### pure function & side effect

- 순수 함수(pure function) : 값을 리턴하는 것만이 유일한 효과인 함수
- 참조 투명성(referential transparency) : 몇 번을 호출하든 호출 결과가 항상 같은 성질
- side effect : 화면 출력과 상태 변경을 비롯한 기타 모든 결과
- `Haskell`이나 `Scheme`을 비롯한 함수형 언어는 순수 함수와 참조 투명성 개념을 바탕으로 함
- but, 실제 프로그램은 어떠한 식으로든 런타임 환경과 상호작용하므로 함수형 언어는 필수적인 부수효과를 특별하게 구분된 모듈로 감싼다.

### 메서드 계약 예시 - `Iterator` 인터페이스의 `next()`

1. 사전 조건 : `Iterator`가 끝에 다다르지 않아 `hasNext`가 `true`를 리턴한다.
2. 사후 조건 : 반복 순서상 다음 차례의 항목을 리턴하고 `Iterator`는 한 자리 전진한다.
3. 패널티 : 사전 조건이 성립하지 않으면 `unchecked Exception`인 `NoSuchElementException`을 던진다.

### 불변 조건

- 클래스 필드에 대해 항상 참인 조건.
- 특정 시점의 객체 상태를 기술하는 정적 일관성 규칙(static consistency rule)
- 메서드가 실행되는 동안, 클래스가 변화하는 동안을 제외하고 **항상 성립**해야 한다.
- 메서드 계약과 더불어 클래스에는 불변 조건이 존재
- 모든 `public` 메서드는 이를 검증할 책임을 진다. `private` 메서드의 주 목적은 `public` 메서드를 지원하는 역할이므로 불변 조건을 검증할 책임은 없다.

### 소프트웨어 신뢰성 - 정확성, 견고성

- 정확성 : `boolean` 기대한 환경이 주어진다는 가정하에 시스템이 계획대로 작동하는가?
- 견고성 : 예외적이고 예상하지 못한 환경에서 시스템이 잘 동작하는가?
  - 사전 조건이 깨진 상태에서 메서드가 호출되는 상황

### 계약을 구현하고 강제하는 데 도움을 주는 코딩 기법

- `if-기반 확인` : 호출자가 사전 조건을 지키는 방식으로 메서드를 호출했는지 확인하고 그렇지 않으면 패널티를 발생시킨다. (운영 도중 진행되는 모니터링 기법)
- `asserts` : `assert` 구문은 사전 조건과 불변 조건을 확인하는 데 유용하며 안전이 중요한 소프트웨어에서 특히 쓸모 있다. (운영 도중 진행되는 모니터링 기법)
- `테스트` : 소프트웨어의 신뢰성에 대한 확신을 높여줄 수 있으며 주로 사후 조건을 검사하고 패널티를 발생시킨다. (운영 전에 별도로 수행)

### 계약 검사

- 프로그램 오류의 상당수는 메서드의 사전 조건 위반에서 비롯
- 메서드가 런타임에 사전 조건을 확인하고, 적절한 예외를 던져야 함 → 방어적 프로그래밍
  - 주로 `IllegalArgumentException`, `IllegalStateException` 사용
- `assert` 구문은 더 구체적인 검사 메커니즘 제공
  ```java
  assert condition : "Error message!";
  ```
  - 조건(condition)을 평가한 후 조건이 거짓이면 `AssertionError`를 던진다.
  - 오류 메시지는 던져질 예외 객체로 전달돼 예외 객체를 `catch` 하지 않으면 화면에 출력된다.
  - `if`문과의 차이점은 JVM은 기본적으로 `assert` 구문을 실행하지 않으며, `assert` 구문을 실행하려면 JVM의 command line option에 `-ea`를 지정하거나 IDE에서 적절한 설정을 해야한다.
    - `Assertion`을 비활성화하면 불리언 조건을 확인하는 데 성능을 낭비하지 않는다.
    - `Assertion`의 유연함에는 대가가 따르며 제품 배포를 비롯한 모든 경우에 항상 수행해야 하는 검사도 존재
- 계약에 의한 설계는 어떠한 검사가 항상 수행돼야 하는지 간단한 기준을 제공
  - `public` 메서드의 사전 조건은 항상 확인해야 함 → `if`를 이용
  - 사후 조건과 불변 조건, `public`이 아닌 메서드의 사전 조건을 비롯한 다른 모든 확인은 개발하는 동안에만 수행 → `Assertion`을 이용

## 계약을 바탕으로 수조 설계하기

| 메서드    | 사전 조건                                       | 사후 조건                                | 패널티 |
| --------- | ----------------------------------------------- | ---------------------------------------- | ------ |
| getAmount | 없음                                            | 현재 수조에 담긴 물의 양을 리턴함        | 없음   |
| connectTo | 인자가 not null                                 | 두 그룹의 수조를 병합하고 물을 재분배함  | NPE    |
| addWater  | 인자가 음수이면, 그룹에 충분한 물이 존재해야 함 | 그룹의 모든 수조에 같은 양의 물을 분배함 | IAE    |

- NPE vs IAE
  - 다음의 경우 NPE를 사용
    - 어느 값 때문에 문제가 발생했는지 명확할 때
  - 다음의 경우 IAE를 사용
    - 사전 조건 위반으로 문제가 발생한 것이 명확할 때
    - JVM이 만들어내는 NPE와 명확하게 구별될 때
  - 관례적으로 NPE를 선호
    - `Object` 클래스의 유틸리티 메서드에서도 이러한 관례를 적용
- 불변 조건
  - 모든 수조의 `amount` 필드는 음수가 아니다.
  - 모든 수조는 한 그룹에만 속한다.
  - 각 수조의 `group` 필드는 `null`이 아니고 `this` 객체를 포함하는 수조를 가리킨다.
  - 같은 그룹에 속하는 모든 수조의 `amount` 필드는 같은 값을 갖는다.

## 결론

- 소프트웨어의 신뢰성은 명확한 명세에서 시작된다.
- 표준적인 명세는 메서드 계약과 클래스 불변 조건을 바탕으로 한다.
- 개발 과정 전체에 걸쳐 `public` 메서드의 사전 조건을 검사해야 한다.
- 개발이 진행중이거나 안정성이 중요한 소프트웨어라면 필요에 따라 사전 조건과 사후 조건, 불변 조건을 검사한다.
- 어셔선을 이용하면 프로그램을 실행할 때 일부 검사를 활성화하거나 비활성화할 수 있다.

## 퀴즈 & 연습 문제

### **‼️️ [돌발 퀴즈 1] 패널티로 checked exception을 던지지 않는 이유는?**

→ 예외 처리를 강제하지 않기 위해

⇒ 사전 조건만 준수하면 패널티를 방지할 수 있는데, checked exception을 던지면 호출자가 강제로 해야 하기 때문에 귀찮아진다. 따라서 호출자가 직접 통제할 수 없는 경우에만 checked exception을 던져야 한다.

### **‼️️ [돌발 퀴즈 2] 종이에 인쇄하는 프로그램의 종이가 떨어졌을 때 우아한 대처법은?**

→ 종이가 떨어졌다고 알리고 인쇄할 내용을 저장해두고 종이를 기다리다 프로그램을 종료

⇒ 문제를 사용자에게 알린 후 인쇄를 재시도하거나 취소할 기회를 주는 것

### **‼️️ [돌발 퀴즈 3] ”`addWater`에 0을 전달하면 모든 수조에 변화가 일어나지 않는다.”라는 조건은 `Container` 클래스의 유효한 불변 조건인가?**

→ 🆗

⇒ 메서드 호출 전후의 상태를 비교하므로 불변 조건이 아니라 사후 조건이다. 불변 조건은 객체의 현재 상태만 가리킨다.

### **‼️️ [돌발 퀴즈 4] `Assertion`이 활성화됐을 때만 불리언 플래그를 `true`로 설정하는 방법은 무엇일까?**

→ assertion 안에서 `true`로 설정

⇒ 플래그를 `false`로 초기화한 후 dummy assertion 안에서 `true`로 설정

```java
boolean areAssertionsEnabled = false;
assert (areAssertionsEnabled = true) == true;
```

### **‼️️ [돌발 퀴즈 5] `addWater`에 `Double.NAN`을 인자로 전달하면 어떻게 될까?**

→ 실패

⇒ NaN은 특별한 산술 규칙을 따르는데 문제에서 고려해야 할 규칙은 다음과 같다.

- NaN/n → NaN
- NaN+n → NaN
- NaN<n → false
- NaN==NaN → false

---

사전 조건 검사는 `this.amount + amountPerContainer < 0`이 `false`로 평가돼 통과

그룹에 포함된 모든 수조에 NaN값이 저장

사후 조건 검사는 NaN으로 인해 `isGroupBalanced()`와 `almostEqual()`이 모두 실패하면서 `AssertionError`를 던지며 종료

but, Assertion을 비활성화한 경우 아무 증상 없이 모든 수조에 NaN값이 저장됨

따라서 사전 조건에서 이러한 값을 유효하지 않은 값으로 선언하는 것도 좋은 방법

### [연습 문제 1]

[https://docs.oracle.com/javase/8/docs/api/index.html](https://docs.oracle.com/javase/8/docs/api/index.html)

1. `java.util.Collection` 인터페이스에서 `add` 메서드의 계약을 작성해보자.

   - 사전 조건 - `패널티` : 이 작업을 지원하는 컬렉션에서는 추가할수 있는 요소가 제한될 수 있다.
     - 일부 컬렉션은 `null` 요소를 추가하는 것을 거부 - `NullPointerException`
     - 일부 컬렉션에서는 추가할 수 있는 요소의 타입에 제한 - `ClassCastException`
     - 일부 컬렉션에서는 이 작업을 지원하지 않음 - `UnsupportedOperationException`
     - 요소의 일부 속성으로 인해 컬렉션에 추가 거부 - `IllegalArgumentException`
     - 삽입 제한으로 인해 요소를 지금 추가할 수 없는 경우 - `IllegalStateException`
     - 각 구현 클래스는 추가할 수 있는 요소에 대한 제한 사항을 명세에 정확히 명시해야 함
   - 사후 조건 : 요소를 추가한 후 이 컬렉션이 변경된 경우 `true`를 리턴한다. 컬렉션이 변경되지 않으면 `false`를 리턴한다.

   ⇒ 추상메서드는 구현이 없는 순수 계약이므로 계약이 명확하고 상세해야 한다. `Collection` 인터페이스는 컬렉션 계층 구조의 루트로서 광범위한 범위를 수용할 수 있어야 한다. `Collection.add`는 선택적 연산으로 2가지 대안적 계약이 존재한다.

   - 불변 컬렉션처럼 삽입을 지원하지 않는 구현에 따른 계약
     - 사전 조건 : 어떠한 호출도 불법
     - 사후 조건 : 없다
     - 패널티 : `UnsupportedOperationException`
   - 삽입을 지원하는 구현에 따른 계약
     - 사전 조건 : 구현에 따른다.
     - 사후 조건 :컬렉션이 주어진 요소를 포함해야 하며 호출로 인해 컬렉션이 변경됐으면 `true`를 리턴한다.
     - 패널티
       - 인자 타입이 올바르지 않으면 `ClassCastException`
       - 인자가 `null`이고 컬렉션이 `null` 값을 거부하면 `NullPointerException`
       - 인자가 다른 이유로 유효하지 않으면 `IllegalArgumentException`
       - 현재 상태에서 인자를 삽입할 수 없으면 `IllegalStateException`

2. `java.util.HashSet` 클래스의 `add` 메서드에도 같은 작업을 해보자.
   - 사전 조건 : 없다
   - 사후 조건 : 주어진 인자와 같은 요소가 존재하지 않으면 요소를 삽입하고 `true`를 리턴한다.
   - 패널티 : 없다.
3. 둘이 어떻게 다른지 비교해보자.

   ⇒ `HashSet`의 계약에서는 컬렉션이 중복된 요소를 포함하지 않는다고 명시한다. 하지만 중복 요소를 삽입하려는 시도 자체는 사전 조건을 위반하지 않으므로 오류는 아니다.

### [연습 문제 2]

다음과 같은 계약으로 정의되는 정적 메서드 `interleaveLists`를 구현하자.

- 사전 조건 : 메서드는 같은 길이의 `List` 2개를 인자로 받는다.
- 사후 조건 : 메서드는 두 리스트의 요소가 번갈아 저장된 새로운 `List`를 리턴한다.
- 패널티 : 주어진 두 리스트 중 하나가 `null`이면 `NullPointerException`을 던진다. 두 리스트의 길이가 다르면 `IllegalArgumentException`을 던진다.

사전 조건은 항상 검사하고 사후 조건은 어서션이 활성화된 경우에만 검사하게 하자. 어서션이 비활성화된 경우 오버헤드를 최소화하자.

### [연습 문제 3]

`java.math.BigInteger` 타입의 객체는 임의의 크기의 정수를 표현하며 내부적으로는 정수 배열로 인코딩된다.

- `private BigInteger(int[] val)`
- `private int parseInt(char[] source, int start, int end)`

1. `private` 생성자의 계약을 작성해보자. 생성자가 정상적으로 종료하는 데 필요한 모든 조건을 사전 조건에 포함하자. 생성자가 사전 조건을 능동적으로 검사하는가?

   ⇒ 계약은 다음과 같다.

   - 사전 조건 : `val`은 `null`이 아니며 비어 있지 않다.
   - 사후 조건 : 2의 보수 bog-endian 형태로 인코딩된 정수를 `val`에 저장하는 `BigInteger`를 생성한다.
   - 패널티
     - `val`이 `null`이면 `NullPointerException`
     - `val`이 비어 있으면(길이가 0이면) `NumberFormatException`

2. `parseInt`에도 같은 작업을 해보자

   ⇒ 계약은 다음과 같다.

   - 사전 조건 : `source`는 비어 있지 않은 문자 시퀀스다. `start`와 `end`는 `source`의 유효한 인덱스여야 하며 `start < end`
   - 사후 조건 : `start`와 `end`로 지정된 인덱스 사이의 숫자를 정수로 리턴
   - 패널티
     - `source`가 `null`이면 `NullPointerException`
     - 주어진 구간에 숫자가 아닌 문자가 존재하면 `NumberFormatException`
     - `start`와 `end`가 `source`의 유효한 인덱스가 아니면 `ArrayIndexOutOfBoundsException`

### [연습 문제 4]

`chapter5.exercises.Gcd` 클래스의 `greatestCommonDivisor(int u, int v)` 메서드를 어서션이 활성화됐을 때 사후 조건을 검사하도록 메서드를 수정하고 1,000개 정수 쌍에 이를 실행해보자.
