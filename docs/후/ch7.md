# 7장\_큰소리로 코딩하자: 가독성

### **✔️ check point**

- 읽기 쉬운 코드 작성
- 자바독 주석을 이용한 계약 문서화
- 구현 관련 주석을 자기설명적 코드로 대체하기

## 가독성을 바라보는 관점

- 코드의 의도를 명확하게 표현하는 것
- 가독성은 소프트웨어의 신뢰성과 유지보수성, 발전 과정에 큰 영향을 미침
- 가독성을 향상시킨다는 것 - 개발자가 주어진 코드를 이해하는 데 걸리는 시간(=학습 가능성learnability, 이해 가능성understandability)을 최소화하는 것
- 리팩토링(refactoring) - 미래의 변경을 쉽고 안전하게 할 수 있도록 작동 중인 시스템을 재구성 하는 기술로 빠른 개발 단계와 반복적인 소프트웨어 개선을 선호하는 경량 개발 프로세스의 주재료! 냄새나는 코드 → 클린 코드로 바꾸는 방법
- 주관적인 지표를 수치화 하려는 노력 - 식별자의 길이, 표현식에 포함된 괄호의 개수 등
- 코딩 스타일 가이드
  - [썬(Sun)의 공식 자바 스타일 가이드](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html)
  - [구글 스타일 가이드](https://google.github.io/styleguide/javaguide.html)
  - [트위터 스타일 가이드](https://github.com/twitter-archive/commons/blob/master/src/java/com/twitter/common/styleguide.md)
  - [페이스북 스타일 가이드](https://github.com/facebookarchive/jcommon)
- 가독성에 영향을 미치는 소재
  - 구조적 특징 : 프로그램 실행에 영향을 미치는 특징
    - 아키텍처 수준 : 하나 이상의 클래스와 관련 있는 특징
    - 클래스 수준 : 한 클래스와 그 안에 포함된 모든 메서드와 관련 있는 특징
    - 메서드 수준 : 한 메서드와 관련 있는 특징
  - 외부적 특징
    - 주석이나 공백, 변수 명명 규칙 등 프로그램 실행에 영향을 미치지 않는 특징

## 구조적 가독성 특징

- 아키텍처 수준 : 클래스를 나누는 방식과 그 사이 관계 등을 비롯한 프로그램의 하이 레벨 구조.
  - 좋은 아키텍처 : 기능적 응집력이 큰 소수의 클래스로 구성, 의존성이 복잡하지 않은 느슨한 네트워크로 연결
  - 표준적인 디자인 패턴을 애용한다면 가독성을 높일 수 있음.
- 클래스 수준 : 주어진 클래스의 API와 메서드 구성을 포함
  - 메서드 분리(추출)
  - 제어 흐름 - 주어진 상황, 목적에 가장 부합하는 반목문 선택
    - 각 반복의 끝에서 조건을 검사해야 한다면 `do-while`
    - 기타 상황 `while`
    - 초기화와 갱신이 단순하다면 `for`
    - 인덱스나 반복자 객체가 필요 없고 배열이나 `Iterable`을 구현한 컬렉션을 순회한다면 `enhanced-for` - indexoutofbounds에서도 안전
    - 자바8부터는 스트림을 이용한 함수형 스타일 작성 가능
      - 가독성이 오히려 좋지 않으므로 스트림 내용을 필터링하거나 변환하는 등 단순 루프 이상의 작업을할 때나 병렬 처리시만 함수형 스타일 API를 사용
  - 표현식과 지역 변수
    - 변수 추출 : 하위 표현식을 설명적인 이름의 새로운 지역 변수로 대체
    - 지역 변수를 사용하는 대신 값을 계산하는 새로운 메서드를 호출(임시-질의 대체)

## 외부적 가독성 특징

- 주석
  - 문서화/명세 주석
    - 메서드나 클래스 전체의 계약을 설명. 잠재적 클라이언트가 지켜야 할 규칙을 기술
    - 이러한 주석을 추출해 알아보기 쉬운 형태(HTML)등으로 변환
  - 구현 주석
    - 필드의 역할이나 헷갈리는 알고리즘과 관련 있는 코드 조각의 의도를 비롯한 클래스 내부의 통찰을 제공
    - 메서드의 몸체는 변경이 잦으며 코드가 자주 바뀌면 주석도 자주 빠귀어야 하므로 프로그래머가 주석을 수정하는 것을 잊을 수 있기 때문에 잘못된 정보를 전달할 수 있다.
    - 주석 대신 응집도가 높은 코드 블록을 서술적인 이름을 갖는 메서드로 추출
  - 문서화 주석은 자세하게, 구현 주석은 최대한 줄임. 모든 주석을 최신으로 유지하자.
    - 제대로 작성된 코드는 코드만으로도 계약을 어느 정도 표현할 수 있으며 그 이상 설명이 필요하다면 다른 형태의 문서를 사용
- 이름 짓기
  - 코드에 익숙하지 않은 사람도 이름이 지칭하는 구성 요소의 역할을 쉽게 떠올릴 수 있도록 자기 설명적인 이름을 사용
  - 관례적으로 사용하는 i, x, a, b, T 등등...
  - 클래스 이름은 명사, 메서드 이름은 동사
  - 표준이 아닌 축약어는 이름에 사용하지 않는다.
- 공백 / 들여쓰기
  - 문장 부호 역할을 하는 공백
  - 일관된 들여쓰기
  - 나중에 코드를 읽을 동료 프로그래머의 인지적 부담을 덜어주는 데 사용

## 자바독을 이용한 클래스 헤더 문서화

- 자바독은 소스 파일에서 특별한 방식으로 구성된 주석을 추출해 깔끔한 HTML 형식으로 변환하는 자바 도구
- 원래 자바 API를 위한 익숙한 형태의 온라인 문서를 만들어내지만 IDE의 요청에 따라 즉각적인 문서 조각을 만들때도 사용
- `/**` 로 시작하며 HTML 태그의 대부분을 지원
- `@` 로 시작하는 추가적인 여러가지 태그 지원(애노테이션과 혼동 X)

## private vs public

- 똑같은 멤버라도 `private`가 아닌 `public`으로 선언하면 유지/보수 비용이 훨씬 커진다.
  - 계약을 설명하는 적절한 문서
  - 잘못된 클라이언트와 상호작용에 대비한 사전 조건 검사
  - 정확성에 대한 믿음을 주는 일련의 테스트

## 결론

- 가독성이 시간 효율성이나 공간 효율성을 비롯한 다른 코드 품질과 충돌할 경우 대부분 가독성을 우선 고려해야 함
  - 버그가 발생하거나 새로운 기능이 필요하면 소프트웨어는 필연적으로 진화해야 하며 그 과정에서 가독성은 굉장한 이점
  - 코드의 명확성 ≠ 알고리즘의 단순성 → 목표에 적합한 알고리즘을 선택해 최대한 깔끔하게 구현하기 위해 노력

## 퀴즈 & 연습 문제

### ‼️ **[돌발 퀴즈 1] 가독성의 영향을 받는 품질 속성은 무엇일까?**

→ 유지보수성👍 , 시간 효율성👎, 공간 효율성👎

⇒ 읽기 쉬운 코드는 이해하기도 쉽고 수정할 때 안전하므로 가독성은 신뢰성과 유지보수성에 좋은 영향을 미친다.

### ‼️ **[돌발 퀴즈 2] n개 정수를 포함하는 배열을 0부터 n - 1 까지 초기화 한다면 어떠한 루프를 사용해야 할까?**

→ `for`

### ‼️ **[돌발 퀴즈 3] `private` 메서드의 동작을 설명하는 메서드는 명세 주석일까, 구현 주석일까?**

→ 구현 주석

⇒ private 메서드는 클라이언트에 노출되지 않으므로 private 메서드의 동작을 설명하는 주석은 구현 주석으로 간주한다.

### ‼️ **[돌발 퀴즈 4] `Employee` 클래스에서 월급을 저장하는 필드의 이름으로 `salary`, `s`, `monthlySalary`, `employeeMonthlySalary` 중 어느 이름이 좋을까?**

→ **`monthlySalary`**

### ‼️ **[돌발 퀴즈 5] 어떠한 `public` 메서드가 클래스 불변 조건을 위반하면 `AssertionError`를 던진다고 가정해보자. 이 사실을 메서드의 자바독 문서에 언급해야 할까?**

→ 🙅‍♀️

⇒ **`AssertionError`는 내부적인 오류가 발생했을 때만 던지므로 문서화하면 안된다.**

### [연습문제 1]

```java
List<String> names;
double[] lengths;
```

위와 같은 데이터가 주어졌을 때 다음과 같은 작업을 수행하려면 어떠한 종류의 루프를 사용해야 할까?

1. 리스트의 모든 이름을 출력한다.

   → enhanced-for

2. 길이가 20자보다 긴 이름을 리스트에서 제거한다.

   → stream

   ⇒ while

3. 모든 이름의 길이를 더한다.

   → enhanced-for, stream

4. 배열에 길이가 0인 항목이 있으면 불리언 플래그를 true로 설정한다.

   → enhanced-for, stream

### [연습문제 2]

public char charAt(int index)의 계약을 설명하는 자바독 문서를 작성해 공식 문서와 비교해보자.

```java
/**
 * 문자열의 index에 해당하는 문자를 반환한다.
 *
 * @param index 인덱스
 * @return 문자열의 index에 해당하는 문자
 * @throws index가 유효하지 않으면 IndexOutOfBoundsException
 */
public char charAt(int index)
```

```java
/**
 * 주어진 인덱스에 위치한 {@code char} 값을 리턴한다.
 * 인덱스틑 {@code 0}에서 {@code length() - 1} 까지의 구간에 속한다.
 * 시퀀스의 첫 번째 {@code char} 값의 인덱스는 {@code 0},
 * 다음 인덱스는 {@code 1}과 같이 배열의 인덱싱 방식을 따른다.
 *
 * @param index {@code char} 값의 인덱스
 * @return 이 문자열의 주어진 인덱스에 위치한 {@code char} 값
 *         첫 번째 {@code char} 값의 인덱스는 {@code 0}이다.
 * @exception IndexOutOfBoundsException {@code index 인자가
              음수이거나 이 문자열의 길이 이상이다.
 */
public char charAt(int index)
```

### [연습문제 3]

다음과 같은 메서드가 어떠한 작업을 하는지 추측하고 가독성을 개선하자.

```java
    public static int f(String s, char c) {
        int i = 0, n = 0;
        boolean flag = true;
        while (flag) {
            if (s.charAt(i) == c)
                n++;
            if (i == s.length() -1)
                flag = false;
            else
                i++;
        }
        return n;
    }
```

### [연습문제 4]

이 메서드는 byte 타입의 인접 행렬로 표현된 그래프에서 너비 우선 방문을 수행한다. 두 단계에 걸쳐 이 메서드의 가독성을 개선하자.

1. 변수 이름과 주석을 수정해 외형적인 변화를 가하자.
2. 구조적 변화를 가하자.

모든 변화는 API(파라미터 타입)와 가시적 행위(화면 출력)을 그대로 유지해야 한다.
