# Ch5 모니터링을 이용한 신뢰성 향상

## 사전 조건과 사후 조건

사전 조건 : 메서드가 올바로 기능하는 데 필요한 요구 사항 (완벽하게 제어할 수 있는 성질의 조건만 가능)

- 호출자의 책임 (의무)
- 피호출자의 이득

사후 조건 : 메서드의 효과, 리턴 값, 관계된 모든 객체의 상태 변화

- 잘 설계된 클래스라면 메서드 호출 후의 변화는 해당 객체에만 한정되어야 함
    
    **패널티** : 사후 조건에서 호출자가 사전 조건을 어겼을 시에 대한 조치(ex 예외)
    

→ 사후조건은 결국 메서드가 기대한 대로 동작하는지를 체크하는 것이다.

ex) 덧셈을 수행하는 메서드의 사후 조건 확인은 덧셈이 제대로 되는지 체크하는 것

<br>

## 불변 조건

클래스 필드에 대해 항상 참인 조건

- 메서드가 실행될 때와 클래스가 변화할 때를 제외하고 항상 성립해야 함

→ 특정 시점의 객체 상태를 나타내므로 정적 일관성 규칙

‼️ 사후조건은 메서드 실행 전후의 객체 상태를 비교하므로 동적 일관성 규칙이다.

<br>

## 정확성과 견고성

정확성 → 시스템이 정확하다는 것은 기대한 환경이 주어진다는 가정하에 시스템이 계획대로 작동한다는 것

견고성 → 예외적이고 예상치 못한 환경에서 시스템이 어떻게 동작하는지를 다루는 것

<br>

## 계약 검사

메서드 사전 조건 위반으로 인해 프로그램 오류가 발생하는 경우가 많음

→ 런타임에 사전 조건을 확인하고 예외를 던지는 것이 필요 → 방어적 프로그래밍

‼️자주 쓰이는 예외

- IllegalArgumentException : 인자 값이 사전 조건을 위반하는 경우
- IllegalStateException : 객체 상태가 호출된 인스턴스 메서드오 ㅏ호환되지 않거나 주어진 인자 값과 호환되지 않는 경우 → ex) 이미 닫은 파일을 다시 읽을려고 할 때

<br>

**`assert condition : "if condition is false then throw error message";`**

assert는 기본적으로 실행되지 않는다. `-ea`옵션을 주고 컴파일을 해야 실행이 된다.

<br>

`public` 메서드의 사전 조건 → 항상 확인해야 하기 때문에 `if`문으로 확인

`public`이 아닌 메서드 → 개발 시에만 확인하는 것으로 충분 → assert 사용

<br>

## 계약을 바탕으로 수조 설계

모든 사전조건과 사후조건을 확인하는 건 비용도 크고 귀찮은 일

→ 사후 조건을 불변 조건으로 변경하면 검사하기 편해짐

<br>

| 메서드 | 사전 조건 | 사후 조건 | 패널티 |
| --- | --- | --- | --- |
| getAmount | 없음 | 현재 수조에 담긴 물의 양을 리턴 | 없음 |
| connectTo | 인자는 Null이 아님 | 두 그룹의 수조를 병합하고 물을 재분배함 | NullPointerException |
| addWater | 인자가 음수이면 그룹에 충분한 물이 존재해야 함 | 그룹의 모든 수조에 같은 양의 물을 분배함 | IllegalArgumentException |

<br>

‼️ 사후 조건을 확인하는 것의 이점

사후 조건을 확인하기 위해서는 코드가 길어짐

→ 사후 조건을 확인하는 로직에서 실수가 발생할 수 있음

→ 검사 하는 내용이 메서드가 수행한 계산을 단순하게 반복하는 것이라면 무의미한 노력

→ 결과가 올바른지 확인할 다른 방식, 더 간단한 방식을 찾는다면 기존방법 + 간단한 방식 2가지로 사후 조건 체크

→ 클래스를 더 이해하는 계기

<br>

나는 동의 못함.

코드 로직을 짤 때부터 생각하고 잘 설계해서 잘 동작하도록 짜야지 이런식으로 사후조건을 체크한다? 바보같은 짓

테스트코드를 통해서 테스트하면서 짜는게 훨씬 효율적이고 검증도 간단한 것 같음

<br>

<br>

## 요약

- 소프트웨어의 신뢰성은 명확한 명세에서 시작된다
- 개발 과정 전체에 걸쳐 public 메서드의 사전 조건을 검사해야 함 → if

<br>

**돌발 퀴즈 1**

Q) 패널티로 확인된 예외를 던지지 않는 이유는 무엇일까?

Checked Exception을 던지면 호출자쪽에서 무조건 예외처리가 강제되기 때문에 코드의 가독성도 떨어트리고 프로그래밍하기에도 불편함을 느끼기 때문이다.

<br>

**돌발 퀴즈 2**

Q) 프로그램이 종이에 인쇄한다면 종이가 떨어졌을 때 우아한 대처법은 무엇일까?

양면출력

한페이지에 4쪽씩 출력? → 이건 이미 종이가 떨어졌으면 소용이 없는데

종이사러 나갔다옴

<br>

**돌발 퀴즈 3**

Q) addWater에 0을 전달하면 모든 수조에 변화가 일어나지 않는다 → 유효한 불변조건인가?

~~그런 거 같은데~~

메서드 전 후 비교이므로 사후조건

<br>

**돌발 퀴즈 4**

Q) 어서션이 활성화됐을 때만 불리언 플래그를 true로 설정하는 방법은 무엇일까?

```java
boolean flag = false;
assert (flag = true) == true
```

<br>

**돌발 퀴즈 5**

Q) addWater에 수가 아님(not a number, ex) Double.NAN)을 인자로 전달하면 어떻게 될까? 

| 수식 | 결과 |
| --- | --- |
| NaN / n | NaN |
| NaN + n | NaN |
| NaN < n | false |
| NaN == NaN | false |

<br>

**연습 문제 1**

1) java.util.Collection 인터페이스에서 add 메서드의 계약을 작성해보자

- 불변 컬렉션
    - 사전 조건 : 어떠한 호출도 불법
    - 사후 조건 : 없음
    - 패널티 : `UnsupportedOperationException`
- 일반적인 컬렉션
    - 사전 조건 : 구현에 따름
    - 사후 조건 : 컬렉션이 주어진 요소를 포함해야 하며 호출로 인해 컬렉션이 변경되었으면 true를 반환
    - 패널티
        - `ClassCastException` → 인자 타입이 올바르지 않을 때
        - `NullPointerException` → 인자가 null이고 컬렉션이 null을 받지 않을 때
        - `IllegalArgumentException` → 인자가 유효하지 않을 때
        - `IllegalStateException` → 현재 상태에서 인자를 삽입할 수 없을 때

2) java.util.HashSet 클래스의 add 메서드에도 같은 작업을 해보자

- 사전 조건 : 없음
- 사후 조건 : 주어진 인자와 같은 요소가 존재하지 않으면 add후 true를 반환
- 패널티 : 없음

3) 둘이 어떻게 다른지 비교해보자

중복된 요소를 포함하는 것과 포함하지 않는 것

<br>

**연습 문제 2**

code/제리/src/ch5/prac2/PracticeList.java 에 구현

<br>

**연습 문제 3**

1. private 생성자의 계약을 작성해보자
- 사전 조건 : val은 null이 아니며 비어 있지 않다.
- 사후 조건 : 2의 보수 빅엔디안 형태로 인코딩된 정수를 val에 저장하는 BigInteger를 생성
- 패널티
    - val이 null이면 `NullPointerException`
    - val이 비어 있으면 `NumberFormatException`

1. parseInt 메서드에 같은 작업을 해보자
- 사전 조건 : source는 비어 있지 않은 문자 배열이여야 하고 start와 end는 source의 유효 인덱스여야 하고 start가 end보다 작아야 한다
- 사후 조건 : start와 end로 지정된 인덱스 사이의 숫자를 정수로 리턴
- 패널티
    - source가 null이면 `NullPointerException`
    - 주어진 구간에 숫자가 아닌 문자가 존재하면 `NumberFormatException`
    - start와 end가 source의 유효한 인덱스가 아니라면 `ArrayIndexOutOfBoundsException`

