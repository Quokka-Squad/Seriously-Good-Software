# 6장

6장에서 다루는 내용

- 단위 테스트 슈트 설계
- 입력 커버리지 기준 적용
- 코드 커버리지 측정
- 코드 테스트 용이성 평가와 개선

<br>

테스트의 목표

- 최대한 많은 버그를 찾아내 제거하는 것
    
    → 정확성과 견고성을 개선


<br>

테스트 커버리지

1. 코드 기반 커버리지 (화이트박스 테스트와 관련)
    - 테스트 집합에서 한 번이라도 실행되는 코드의 비율
2. 입력 기반 커버리지 (블랙박스 테스트와 관련)
    - 테스트 프로그램의 내부 구현은 상관하지 않고 API에 집중


<br>

커버리지 측정

- 명령어 커버리지
    - 실행된 바이트코드 명령어의 비율
- 행 커버리지
    - 실행된 자바 코드 행의 비율을 나타냄
- 분기 커버리지
    - if, switch 구문을 포함해서 실행한 분기문의 비율을 나타냄


<br>


테스트와 계약에 의한 설계

→ 불변 조건과 사후 조건 검사를 클래스 밖(테스트코드)으로 옮길 수 있음

입력 도메인 모델링

의미 있는 제한된 입력 값 집합을 얻을 수 있음

1. 연관된 입력의 특성을 몇 가지로 정의
    
    ‼️ 특성 : 가능한 입력 값 전체의 집합을 유한한 유형으로 분할
    
2. 특성을 조합해 유한한 집합을 만듬
3. 각 조합에서 선택한 입력 값으로 테스트 구성

‼️ 특성을 선택하는 방법


<br>


표준적인 특성

- 수치 타입에서 0은 다른 값과 특징이 다르므로 분류하는 것이 좋음
- API에서 음수와 양수는 보통 다르게 취급하므로 구분해야 함
- 모든 참조 타입에 대한 null 체크
- 문자열, 배열, 컬렉션에 대해 빈 경우 (empty) 확인

| 타입 | 특성 | 블록 |
| --- | --- | --- |
| int/long | 부호 | {음수, 0, 양수} |
| float/double | 부호와 특수한 값 | {음수, 0, 양수, 무한대, NaN} |
| String | 길이 | {null, 빈 문자열, 비어 있지 않은 문자열} |
| 배열이나 컬렉션 | 크기 | {null, 빈 배열/컬렉션, 비어 있지 않은 배열, 컬렉션} |

<br>

‼️ 블록 조합을 선택하는 방법

- 전체 조합 커버리지
- 개별 선택 커버리지 : 각 특성에서 파생된 모든 블록이 적어도 한 테스트에서 사용
- 기반 선택 커버리지 :  기반이 되는 블록 조합을 선택한 후 어떠한 특성의 모든 값이 등장할 때까지 해당 특성 하나만 변경

‼️ 어떠한 특성 값이 **사전 조건**을 위반해 예외가 발생하면 일반적으로 모든 경우를 테스트 하지 않고 한 번만 테스트한다.

<br>

테스트 용이성

1. 제어 가능성이 높아야하고
2. 관측 가능성이 높아야 하고
3. Mock 객체등을 통해 고립하여 테스트 (만약 Mock 개체 없이 구현되어 있다면 구현한 코드를 넣는 것이 더 바람직하다고 함 by whiteship)

❓테스트 용이성을 좋게하기 위해서 캡슐화를 위반하는 것이 옳은 것일까?

<br>

요약
- 입력 도메인 모델 방법론을 통해 의미 있는 테스트 입력을 찾을 수 있음
- 여러 파라미터의 입력 값을 어떻게 조합하냐에 따라 테스트 수와 커버리지 수준이 달라짐
- 입력 커버리지와 코드 커버리지를 바탕으로 테스트 커버리지 평가 가능
- 메서드의 피드백을 추가하면 테스트 용이성 개선 가능
- 의존성 주입을 이용하면 테스트할 클래스의 의존성을 간단하게 대체해 클래스를 고립시킬 수 있음


<br>

**돌발 퀴즈 1**

Q) 메서드 계약의 어느 부분이 메서드 테스트와 관련 있는가?

사후조건, 불변조건?

<br>

계약의 모든 부분은 테스트와 관련이 있음

대부분의 단위 테스트는 대상 메서드에 적법한 입력을 제공한 후 출력이 사후 조건을 준수하는지 검사

<br>

**돌발 퀴즈 2**

Q) 날짜를 표현하는 데이터 타입에는 어떠한 특성이 있을까?

1 ~ 12월마다 다른 일 수

4년마다 2월이 29일까지 있음

<br>

| 이름 | 특성 | 블록 |
| --- | --- | --- |
| C1 | 윤년 | {true, false} |
| C2 | 달의 길이 | {28, 29, 30, 31} |
| C3 | 달에 속하는 일 | {첫 날, 중간, 마지막 날} |

<br>

**돌발 퀴즈 3**

Q) 독립적인 세 특성이 존재하고 각 특성에 따른 블록 개수가 n1, n2, n3 이라면 전체 조합 커버리지를 달성하는 데 몇 개의 테스트가 필요한가? 개별 선택 커버리지와 기반 선택 커버리지에는 몇 개의 테스트가 필요한가?

전체 조합 커버리지 : n1 * n2 * n3 개

개별 선택 커버리지 : 최소 max(n1, n2, n3) 개

기반 선택 커버리지 : n1 + n2 + n3 - 2 개

<br>

**돌발 퀴즈 4**

Q) 프로그램이 assert 구문을 포함한다면 테스트 할 때 어서션을 활성화해야할까, 비활성화해야 할까?

테스트 한다는 것은 결국 클라이언트가 사용하도록 하는 것(assert 구문을 컴파일 안하는 상태)이므로 비활성화 한 후에 테스트를 해야 한다고 생각한다.

<br>

2가지 방법 모두 활용함

먼저 배포 환경과 동일하게 어서션 없이 테스트 한 후에 테스트에 실패하면 어서션을 활성화 해 결함을 찾는 과정에서 도움을 받는다.

<br>

**돌발 퀴즈 5**

Q) 파일에서 수조 객체를 읽는 정적 메서드를 Container 클래스를 추가하면 테스트 용이성에 어떠한 영향을 미칠까?

클라이언트로부터 입력을 받는 것이 아니라 파일에 적힌 데이터로부터 입력을 받는 것이므로 제어 가능성이 낮게 된고 생각한다. → 테스트 용이성을 떨어트린다.

<br>

**돌발 퀴즈 6**

Q) 현재 수조에 직 간접적으로 연결된 수조의 개수를 리턴하는 public 메서드를 Container 클래스에 추가하면 테스트 용이성에 어떠한 영향을 미칠까?

테스트 용이성은 높아지겠지만 절대 해서는 안되는 짓이라고 생각한다. (굳이 캡슐화를 저해하면서까지 테스트를 해야 할까? 라는 의문이 있음)

<br>

읽기 전용 메서드는 안전하고 객체의 상태를 관찰할 수 있는 수단을 제공하므로 테스트 용이성에 도움을 준다. 결과적으로 추가하면 테스트 용이성이 개선된다.
