### 8장에서 다루는 내용

- 교착 상태와 경합 조건 인지하고 회피하기
- 명시적인 락 사용
- 락-프리 동기화 사용
- 클래스를 불변으로 설계하기

<br>

<br>

<img width="422" alt="스크린샷 2022-02-25 23 35 30" src="https://user-images.githubusercontent.com/81368630/155733247-882594d0-8174-4bef-a8e1-3ec6deb16895.png">

이상적으로 최대한의 동시성을 달성하면서 스레드 안정성을 보장해야 한다. 이를 위해 아래 두 단계가 필요하다.

1. 명세 단계 : 경합 조건 없이 동시에 실행 가능한 메서드나 코드 조각을 알아낸다.
2. 구현 단계 : 불법적인 동시 접근을 직렬화하고 합법적인 동시 접근만 허용하는 동기화 요소를 추가한다.

<br>
<br>

### 교착 상태 다루기

1. 원자적 락 시퀀스
    - ReentrantLock Class
        
        → 락 시퀀스 자체를 원자적으로 만드는 방법 → 두 시퀀스를 동시에 수행할 수 없게 막음
        
    
    ```java
    private static final ReentrantLock globalLock = new ReentrantLock();
    
    public void connectTo(Container other) {
    	globalLock.lock();
    	synchronized (group) {
    		synchronized (other.group) {
    		globalLock.unlock();
    		//group와 other.group를 이용한 connectTo하기 위한 연산
    		}
    	}
    }
    ```
    
2. 순서 있는 락 스퀀스
    - 순서를 정해준 후 순서에 맞춰서 락을 획득하게 하는 것
        
        → 각 그룹에 정수 ID를 할당해서 순서를 배정함 (AtomicInteger)


<br>
<br>
        

사실 위에 두 가지의 시퀀스는 쓰레드 안정성이 완벽하지 않음

- 해결법 1. 받은 값이 쓰레기값이 아닌지 체크한 후 로직 수행

    -  받은 값이 쓰레기값이라면 while(ture)로 감싸져 있기 때문에 다시 올바른 값을 받을때까지 반복함

- 해결법 2. 불변 클래스를 통해서 해결 가능

    - (기존의 객체를 복사해서 본사된 객체의 값을 수정한 후 복사된 객체를 반환)

    - 단점 : 더 많은 메모리, 더 많은 시간복잡도를 요구함

<br>
<br>

### 요약

- 합리적인 동시성 정책은 스레드 안전성에 지극히 필수적이다.
- 스레드 안전성의 가장 큰 적은 경합 조건과 교착 상태다.
- 전역 락이나 순서 있는 락 정책을 이용해 교착 상태를 회피할 수 있다.
- 암묵적 락과 달리 명시적 락(ReenterantLock)은 원하는 순서대로 획득하고 해제할 수 있다.
- 불변성은 스레드 안전성의 대안적 방법이다.

<br>
<br>

**돌발 퀴즈1**

Q) 클래스의 사용자와 구현자 중 어느 쪽이 동시성 정책을 고려해야 할까?

구현자가 동시성을 고려해서 설계를 해야 한다.

<br>

**돌발 퀴즈2**

Q) 각 스레드가 한 번에 하나의 락만 획득할 때도 교착 상태가 발생할 수 있을까?

발생할 수 있을 것 같은데..

→ 재진입이 가능한 락이라면 (락을 획득한 스레드가 락을 다시 획득할 수 있다면) 교착 상태가 발생할 수 없다.

자바에서 락은 모두 재진입이 가능하기 때문에 교착 상태가 발생하지 않는다.

하지만 락이 재진입 불가라면 소유한 락을 다시 획득하려는 스레드는 교착 상태에 빠지게 된다.

<br>

**돌발 퀴즈3**

Q) synchronized 블록 안에서 예외가 발생하면 어떻게 될까? ReentrantLock을 소유한 스레드가 예외를 던지면 어떻게 될까?

→ synchronized 블록 안에서 예외가 발생하면 락이 자동 해제된다. 반면 ReentrantLock은 직접 해제해야 한다. 따라서 finllay 믈록에 unlock을 꼭 호출해야 한다.

<br>

**돌발 퀴즈4**

Q) 순서 있는 락 기법이 교착 상태를 방지하는 이유는 무엇인가?

교착상태는 스레드 하나가 1을 가지고 2을 요구하고 다른 스레드는 2을 가진 상태로 1을 요구하는 상태에서 발생한다. 이를 방지하고자 자원에 순서를 할당함으로써 2를 가진 상태로 1을 요구하는 행위를 막아 교착 상태에 빠질 수 없도록 하는 것이다.

<br>

**돌발 퀴즈5**

Q) 불변 클래스가 자연적으로 스레드 안전한 이유는 무엇인가?

→ 객체가 읽기만 가능하고 여러 스레드에서 동시에 읽더라도 안전성에 문제가 없다.

<br>

**연습 문제1**

(c), (e)

→ 사실 run 메소드 자체에 synchronized 다는게 제일 안전하지 않을까?

<br>

**연습 문제2**

문제 보고 따라 침

<br>

**연습 문제3**

```java
public synchronized void befriend(SocialUser other) {
	friends.add(other);
	other.firends.add(this);
}
```

어차피 a.befriend(b) 와 b.befriend(a) 일 때 `other.firends.add(this)` 에 synchronizd (other)를 붙여서 데드락이 발생하는데 어차피 friends가 Set이니까 a.befriend(b), b.befriend(a)가 같이 호출되어도 위와 같이 작성하면 문제 없지 않나?

<br>

**연습 문제4**

불변 클래스로 return 해주면서 쓰레드 안정성을 확보할 수 있다.
