# 모니터링을 이용한 신뢰성 향상

## 5장에서 다루는 내용

- 계약 형태로 메서드 명세 작성하기
- 런타임에 계약 준수 강제하기
- 어서션 사용하기
- 사후 조건의 가벼운 대안으로서 클래스 불변 조건 확인하기

## 계약에 의한 설계

- 계약에 의한 설계 방법론에서는 메서드마다 계약을 부과한다.
- 메서드 계약은 사전 조건, 사후 조건, 페널티로 이뤄진다.

### 사전 조건과 사후 조건

- 사전 조건
  - 메서드가 올바로 기능하는 데 필요한 요구사항 (파라미터의 적절한 값, 현재 객체의 상태 등)
  - 사전 조건을 지키는 것은 호출자의 책임이다.
    - 그렇기 때문에 사전 조건은 호출자가 완벽하게 제어할 수 있는 조건만 포함해야 한다.
  - 예외 처리는 checked exception이어야 한다.
- 사후 조건
  - 메서드의 효과와 리턴 값, 관계된 모든 객체의 상태 변화를 기술한다.
  - 호출자가 사전 조건을 어겼을 때의 페널티도 명시해야 한다.
  - 자바에서는 페널티를 주로 unchecked exception을 통해 처리한다.

### 불변 조건

- 클래스가 변화하는 동안을 메서드가 실행되는 동안 제외하고 항상 성립해야 한다.
- 메서드 실행 전후 항상 성립해야 한다.

### 정확성과 견고성

- 정확성 : 기대한 환경이 주어진다는 가정하에 시스템이 계획대로 작동한다.
- 견고성 : 예외적이고 예상하지 못한 환경에서 시스템이 어떻게 동작하는지를 다룬다.
  - 문제의 원인을 사용자에게 알리고 사용자가 나중에 작업을 순조롭게 다시 시작할 수 있도록 데이터 손실을 최소화해야 한다.

## 계약을 바탕으로 수조 설계하기

| 메서드    | 사전 조건                                      | 사후 조건                                | 페널티 |
| --------- | ---------------------------------------------- | ---------------------------------------- | ------ |
| getAmount | 없음                                           | 현재 수조에 담긴 물의 양을 리턴함        | 없음   |
| connectTo | 인자는 null이 아님                             | 두 그룹의 수조를 병합하고 물을 재분배함  | NPE    |
| addWater  | 인자가 음수이면 그룹에 충분한 물이 존재해야 함 | 그룹의 모든 수조에 같은 양의 물을 분배함 | IAE    |

## connectTo

### 사전 조건, 패널티

- 인자는 null이 아님(사전 조건), 인자가 null일 경우 NPE(페널티) 

  ```java
  Objects.requireNonNull(other, "Cannot connect to a null container.");
  ```

### 사후 조건

- `areGroupMembersCorrect(ConnectPostData postData)` 
  - 합쳐진 group에 합쳐지기 전의 두 그룹이 모두 포함되어 있어야 한다.
  - 두 그룹의 크기가 합쳐진 그룹의 크기와 같아야 한다.
- `isGroupTotalAmountCorrect(ConnectPostData postData)` : 두 수조의 그룹의 amount 값의 합이 현재 그룹의 amount 값의 합과 같아야 한다(오차범위 절댓값 0.0001) 
  - 기존에 있던 `isGroupAmountCorrect` 메서드는 검증 로직과 비지니스 로직이 같기 때문에 의미가 없다고 생각해서 없애고 `isGroupTotalAmountCorrect` 메서드를 만들었지만 큰 차이가 없는 것 같다.
  - almostEqual 메서드를 재사용해서 만들었다.
- `isGroupBalanced()` : 모든 그룹에 있는 수조의 amount 값이 같아야 한다.
- `isGroupConsistent()` : 두 수조의 그룹이 모두 같아야 한다.

## addWater

### 사전 조건, 패널티

- 인자가 음수이면 그룹에 충분한 물이 존재해야 한다. 물이 충분하지 않다면 IAE(페널티)

```java
if (this.amount + amountPerContainer < 0)
            throw new IllegalArgumentException("Not enough water to match the addWater request.");
```

### 사후 조건

- 물의 양이 양수여야 한다.
- `isGroupBalanced()` : 같은 group에 있는 수조들의 물의 양이 모두 같아야 한다.
- 더하기 전 그룹의 amount 총합 + 인자값(amount)이 현재 그룹의 amount 총합과 같아야 한다.

## 자동 계약 검사

- 계약을 형식적으로 정의할 수 있는 애드혹 언어가 있다.
- 정의된 계약을 자동으로 검사할 수 있는 도구도 있다.

## 전혀 새로운 문제에 적용해보기

| 메서드   | 사전 조건          | 사후 조건                                                    | 페널티 |
| -------- | ------------------ | ------------------------------------------------------------ | ------ |
| add      | 인자는 null이 아님 | 주어진 요소를 크기가 정해진 집합에 추가한다.<br />추가로 인해 요소의 개수가 용량을 초과하면 가장 오래된 요소를 제거한다.<br />집합에 이미 존재하는 요소를 다시 추가하면 해당 요소를 갱신한다. | NPE    |
| contains | 인자는 null이 아님 | 인자로 주어진 요소가 크기가 정해진 집합에 이미 존재하면 true를 반환한다.<br />이 메서드는 집합을 변경하지 않는다. | NPE    |

## to-do list

- [ ] ConnectPostData를 외부 클래스로 분리하기

- [ ] 현재 사후 조건은 사후 조건과 불변 조건이 섞여있다.

  사후 조건과 불변 조건에 대해 정확히 알아보고 제대로 구분해서 정리해보자.

### 돌발퀴즈 2

- 프로그램이 종이에 인쇄한다면 종이가 떨어졌을 때 우아한 대처법은 무엇일까?
  - 종이가 떨어졌다면 프로그램을 일시 정지하고 종이가 채워질때까지 기다린다.
  - 만약 종이가 채워진다면 프로그램을 다시 실행한다.

### 연습문제 1

- java.util.Collection 인터페이스에서 add 메서드의 계약을 작성해보자
  - 집합의 원하는 위치에 요소를 추가할 수 있다.
    - 만약 요소를 추가하는 위치가 집합의 size보다 클 때 IndexOutOfBoundsException을 발생시킨다.
  - 위치를 정해주지 않으면 집합의 맨 마지막에 요소를 추가한다.  
  - 지금 생각해보니 위에 작성된 계약은 ArrayList에서 add 메서드의 계약을 작성한 것 같다.
  - 여러 자료구조가 상속 받고 각 기능이 천차 만별인데 어떻게 계약을 정할 수 있을까?
  - add 메서드의 계약을 정할 수 있었다면 Collection이나 AbstractCollection에서 이미 구현되었을거라고 생각한다
- java.util.HashSet 클래스의 add 메서드에도 계약을 작성해보자
  - 집합의 맨 마지막에 요소를 추가한다.
  - 만약 이미 집합에 포함되어 있는 요소라면 집합에 추가하지 않는다.
- 둘이 어떻게 다른지 비교해보자
  - Collection의 계약을 제대로 작성하지 못해서 비교하지 못하고있다. 