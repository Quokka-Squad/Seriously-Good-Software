# 1장 소프트웨어 품질과 앞으로 풀어야 할 문제

## 1장에서 다루는 내용
* 서로 다른 관점과 목적에서 소프트웨어 평가하기
* 내적(internal) 소프트웨어 품질과 외적(external) 소프트웨어 품질 구별하기
* 기능적(functional) 소프트웨어 품질과 비기능적(nonfunctional) 소프트웨어 품질 구별하기
* 소프트웨어 품질 기준 사이의 상호작용과 상충성(trade-off)

## 소프트웨어 품질
* 소프트웨어의 전반적인 가치가 아닌 소프트웨어가 지녀야 할 특정 특성

### 소프트웨어의 두 가지 품질 기준
* 내적 품질 vs 외적 품질
* 기능적 품질 vs 비기능적 품질

## 내적 품질과 외적 품질
* 내적 품질 : 소스 코드를 봐야만 알 수 있는 품질
* 외적 품질 : 최종 사용자가 시스템과 상호작용하는 동안 인지할 수 있는 품질
* 두 품질의 경계는 명확하지 않다.
  * 최종 사용자는 일부 내적 품질을 간접적으로 체험할 수 있고 모든 외적 품질은 소스 코드에 의존하기 때문이다.

## 기능적 품질과 비기능적 품질
* 기능적 품질 : 소프트웨어가 무엇을 하는지
  * 소프트웨어가 뭔가를 사용하면 그 효과를 최종 사용자가 체감할 수 있으므로 기능적 품질은 외적 품질이다.
* 비기능적 품질 : 소프트웨어가 어떻게 하는지
  * 코드 자체와 관련있다면 내적 품질
  * 코드로부터 파생된 특성과 관계된다면 외적 품질

## 정확성
* 요구 사항이나 명세를 비롯해 명문화된 목적을 고수하라
* 스스로 달성할 명세를 명확하게 이해하지 못하면 정확성을 높일 수 없다.
* 명세를 규약 관점에서 바라보고 규약을 지키도록 구현하는 방법이 유용하다.
* 테스트롤 통해서 불가피한 결함을 줄일 수 있다.

## 견고성
* 잘못된 입력이나 불리하고 예상하지 못한 외부 조건에 대한 복원력을 갖추자
* 신뢰성 = 정확성 + 견고성
* 견고한 소프트웨어는 어떨까?
  * 입력이 유요한 값인지 확인하고 유효하지 않으면 문제를 적절하게 반응한다.
  * 치명적인 오류가 발생할 때 사용자 데이터와 그 시점까지 수행한 계산 결과를 최대한 저장한 후 중단한다.

## 사용성
* 소프트웨어 사용법을 배우고 그 목표를 달성하는 데 필요한 노력 정도

## 효율성
* 적당한 자원 소모량
* 시간 효율성과 공간 효율성으로 나눌 수 있다.
* 정상적인 운영에 영향을 미칠 정도로 낮은 효율성이거나 성능이 중요한 응용 분야에서는 효율성을 기능적 품질이라고 생각한다.

## 가독성
* 동료 프로그래머가 명확하게 이해해야한다.
* 매우 중요하지만 자주 저평가받기도 한다.

## 재사용성 
* 유사한 문제를 해결하기 위해 코드를 쉽게 재사용할 수 있으며 이를 위해 필요한 변경이 적다

## 테스트 용이성
* 프로그램의 모든 동작을 촉발하고 그 효과를 관측하는 테스트를 얼마나 쉽게 작성할 수 있는가?
* 어제 JK가 슬랙에서 남긴 조언 중에 "print 호출을 Rectangle, Line, Triangle에서 
  하기 보다는 출력을 담당하는 타입을 선언해보세요" 라고 말씀하셨던 이유가 테스트 용이성과 관련있다고 생각한다.

## 유지보수성
* 버그를 쉽게 찾아 수정하고 소프트웨어를 발전시킬 수 있다.
* 분석하기 쉽고 모듈화가 깔끔하게 이뤄져 있다.

## 소프트웨어 품질 기준 사이의 상호작용
* 시간 효율성과 공간 효율성 모두 가독성과 유지보수성을 저해할 수 있다.
  * 최대 성능을 얻으려면 추상화를 희생하는 대신 저수준 코드를 작성해야 하기 때문이다.
* 시간 효율성과 공간 효율성은 서로 충돌한다.
  * 연결 리스트와 이중 연결 리스트처럼 계산을 최소화하고 메모리에 추가 정보를 저장하는 방식이 있다.
* 견고성과 시간 효율성은 서로 충돌한다.
  * 검증하는 부분에서 걸리는 시간만큼 시간 효율성이 떨어지기 때문이다.
  * 여기서 견고성과 공간 효율성 또는 가독성은 영향을 받지 않는다.
* 개발 시간과 소프트웨어 품질은 서로 상충한다.
  * 비스니스상의 이유로 소프트웨어를 빨리 개발해야 하지만, 품질을 최대화하려면 노력과 시간이 필요하다.

# 느낀 점

* 어제까지는 소프트웨어의 품격을 읽으면서 나와있는 처음부터 제가 생각하면서 코드를 작성하는 게 아닌 
  예제 코드가 이해되지 않으면 github에서 다운받고 조금씩 변경했던 게 다였습니다.
* 오늘 아침에 여러분들이 올린 PR을 보고 나서 제 공부 방식에 의문이 생겨서 
  책도 처음부터 다시 읽고 Container도 다시 만들어 봤습니다.
* 하지만 이미 책을 읽으면서 학습했던 코드가 머릿속에 남아 있어서 예제와 거의 동일한 코드를 작성하게 되었습니다.
* 이 부분에 대해서 너무 아쉬웠지만 그래도 직접 만들어보고 학습하면서 
  더 많은 고민과 깨달음을 얻을 수 있었기 때문에 앞으로는 뭐든지 만들어보면서 공부할 예정입니다.

_<!-- 함께 고민해주었으면 하는 부분 -->_