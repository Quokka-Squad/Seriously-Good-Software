## 스레드 안정성을 방해하는 2가지 요소

### 1. 경합 조건
- 동기화를 너무 수행하지 않아서 발생한다.
    - ex) 서로 다른 스레드에서 동시에 하나의 객체에 접근할 경우.

### 2. 교착 상태
- 동기화를 지나치게 했을 때 발생한다.
- 2개 이상의 스레드가 서로 순환하는 형태로 계속 기다리는 상태


### 저수준 동기화 요소  vs 고수준 동기화 요소
- 저수준 동기화 요소 : synchronized 블록, 명시적 락
- 고수준 동기화 요소 : Executor, fork-join, 병렬 스트림

## 동시성 레벨

> 최대한의 동시성 달성 & 스레드 안정성 보장이 가장 이상적이다.

<이를 위해 필요한 2가지 단계>
1. 명세 단계 - 클래스가 동시성을 지원할 수 있는지를 명확하게 한다.
  - 서로 다른 데이터를 사용하는 코드조각을 알아낼 것.
2. 구현 단계 - 합법적인 동시 접근만 허용하는 동기화 요소 추

### 클래스 레벨 동시성
- 클래스 단위로 락이 1개씩
- 오로지 스레드 안정성만을 고려한다면 **전역적 락**을 이요해 모든 메서드를 동기화 하는 방법이 있다.
- 서로 다른 메서드에서 서로 다른 객체(타입은 같고)의 메서드를 호출해도 한번의 호출만 실행.

**단점**
- 동시성의 이점이 사라진다.
- 락을 걸고 해제하는 연산때문에 싱글 스레드에서도 성능 저하가 발생한다.

### 객체 레벨 동시성
- 객체 단위로 락이 1개씩
- 인스턴스 메서드에 synchronized를 추가하는 방식으로 구현
  - 이 방식보다는 private 필드를 모니터로 사용하는게 더 견고하며 동기화를 외부로부터 감출 수 있다는 장점이 있다.
- 각각의 스레드에서 접근하는 메서드가 서로 다른 객체의 메서드라면(타입은 같고) 문제없이 접근이 가능.

### 메서드 레벨 동시성
- 한 객체의 메서드 단위로 락이 1개씩
- 객체 내의 각 메서드가 서로 다른 데이터에만 접근해야한다. -> 즉, 다른 클래스에 속해야하는 데이터가 모여있다는 의미일수도 있음.

### 무제한 레벨
- 무상태 클래스나 불변 클래스에 적용된다.



## 교착 상태를 피하는 법
<예시>
- 수조의 connectTo 메서드는 2가지 그룹에 접근하게 된다.
- 스레드1에서 a.connectTo(b), 스레드2에서 b.connectTo(a)를 호출한다면,
- 스레드 1에서 a에 접근했는데 스레드2에서 b를 먼저 접근하면 서로 남은 하나의 객체에 접근하기 위해 계속 기다리게 된다.

<해결법>
1. 원자적 락 시퀀스
- 2개의 시퀀스를 동시에 수행할 수 없도록 하는 추가적인 글로벌 락이 필요하다.
- 만약 스레드1이 락을 획득하는 시퀀스가 먼저 실행되면, 스레드2가 락을 획득하는 시퀀스는 실행될 수 없다. -> 교착상태를 해결하게 된다.
- 자바의 암묵적인 락은 **획득한 순서의 역순으로 해제된다**
  - ReentrantLock 클래스의 명시적 락을 사용하면 이런 한계는 해결 가능 
  단점
- 전혀 다른 락 집합을 획득하려는 시퀀스도 막힘.

2. 순서 있는 락 시퀀스
- 모니터 사이의 전역적인 순서를 정해두고, 모든 스레드가 이 순서에 맞게 락을 획득하도록 만드는 방식.
- 각 그룹에 유일한 정수 ID를 할당. -> 인스턴스가 생성될때마다 값이 증가하는 전역 변수
  - 해당 변수에 대한 경합조건을 방지하기 위해 **AtomicInteger** 사용
  

락 - 프리 동기화
- 루프를 반복하면서 두개의 수조가 그룹을 참조하는지 확인 후 문제가 있으면 모니터 해제 후 다시 시도. -> **낙관적 동기화**


## 불변성
- 스레드 안전성을 달성하는 다른 방법은 **모든 공유 객체를 불변 객체로 만드는 것.**
- 불변 클래스의 조건은 모든 필드를 final로 선언해야 하며, 참조하는 다른 클래스도 불변이어야한다.

### 영속적 자료구조
- 변경이 필요할때마다 새로운 객체를 리턴하는 방식.
  - 이전 상태의 자료구조에도 여전히 접근이 가능하다.
  - 임시적 자료구조에 비해 공간, 시간 효율성이 떨어진다.

### 임시적 자료구조
- 기존의 자료구조를 변경해서 과거 이력을 제공하지 않는 방식.

### 구현
- 실제 영향을 받는 수조그룹만 복사
- 나머지는 변경 전까지 재사용.


## 돌발퀴즈
돌발퀴즈1
- 구현자 / 사용자는 클래스가 스레드 안전한지만 알면 됨

돌발퀴즈2
- 답을 확인했지만 이해가 안됨. 락 재진입???

돌발퀴즈3
- 락도 자동 해제 됨.
- ReentrantLock은 직접 해제 해줘야한다. -> try-finally로 해제할것.

돌발퀴즈4
- 스레드가 순서대로 접근하기 때문에.

돌발퀴즈5
- 불변객체의 값을 변경할수는 없기 때문에.
- 값을 읽는건 문제가 되지 않는다.


## 연습 문제

연습문제 1
- c와 e

연습문제 2 
- 글로벌 락을 하나 만들어서 세터에서 락 걸기
  - **게터에서도 걸어줘야한다!!**

연습문제 3, 4는 못풀어서 뒤에 정답을 참고했습니다.

