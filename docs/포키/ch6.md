### 테스트를 하는 이유

- 프로그램의 **정확성** 과 **견고성**을 높여준다.
- 디버깅 시간이 줄어든다.

> _버그를 100프로 찾아낼수는 없다._

### 테스트 커버리지

- 해당 애플리케이션의 테스트 케이스를 얼마나 통과하는지를 나타내는 지표. 즉, **코드의 안정성을 나타내는 지표**라고 생각하면 된다.

### 테스트 커버리지를 측정하는 방법

#### 1. 코드 기반 커버리지 (화이트박스 테스트)

- 주어진 테스트 집합에서 한번이라도 실행되는 소스 코드의 비율을 의미한다.
- **실제 앱의 내부 코드를 테스트하는 기법**

#### 2. 입력 기반 커버리지 (블랙박스 테스트)

- 앱의 내부 동작 과정과 방식은 모르고 그냥 **입력값에 대한 출력값이 올바르게 나오는지** 테스트하는 기법.


> 2가지 방식은 서로 보완하는 관계다.


### 테스트 vs 계약에 의한 설계

- 테스트를 이용하면 **불변 조건과 사후 조건 검사를 클래스 밖으로 옮길 수 있다**.
- 테스트를 이용하면 다양한 입력값으로 검사할 수 있다. -> 배포하기 전에 더 많은 버그를 발견할 수 있다.

> 테스트 방식이 더 많이 사용된다.
> 안정성이 엄청 중요한 서비스의 경우, 불변 조건 검사를 추가해서 테스트를 보강할수도 있다.

## JUnit

- 자바의 표준 단위테스트 프레임워크
- Annotation을 사용해서 간단하게 테스트 코드를 작성할 수 있다.
- JUnit4 는 하나의 jar 파일에 저장되어 있다.
- Junit5는 3가지 모듈로 구성되어 있다.
    - JUnit Platform : JVM 위에서 테스트를 실행할 수 있는 환경과 `TestEngine` 인터페이스를 제공한다.
    - JUnit Jupiter : JUnit5 기반의 테스트를 실행시킬 수 있는 `TestEngine` 구현체.
    - JUnit Vintage : JUnit3, JUnit4로 작성된 테스트코드를 문제없이 실행시킬 수 있도록 하는 `TestEngine` 구현체.


## AssertJ

- 테스트코드의 가독성, 편의성을 높여주는 오픈소스 라이브러리
- 메서드 체이닝을 지원해 더 가독성 높은 테스트를 작성할 수 있다.
- 책에서 나온 Hamcrest를 추천해주지만 assertj가 가독성이 훨씬 좋다.

```java
assertThat(실제 값).isEqualTo(기대값);
assertThatThrownBy(()-> throw new IOException()).isInstanceOf(IOException.class );
```

## 수조 테스트

1. 테스트 초기화하기
    - 여러 테스트가 공유하는 객체를 **테스트 비품**이라고 한다.

```java
public class UnitTest {
    private Container a, b;

    @BeforeEach
    public void setUp() {
        a = new Container();
        b = new Container();
    }
}

```

### 입력 도메인 모델링
- 테스트할 메서드에 넘겨줄 입력값을 체계적으로 선택하는 방법.
- 메서드에 적합한 의미있는 제한된 입력 값 집합을 얻을 수 있다.

#### 과정

1. 연관된 **입력 특성**을 정의한다.
    - 작은 유형들로 분할하는것을 의미한다. 각각의 작은 유형들을 블록이라고 한다.
        - 정수 입력값은 음수, 0, 양수 3가지 블록으로 나뉜다.
        - 정수 입력값은 홀수, 짝수 2가지 블록들로 나뉜다.
2. 해당 특성들로 **집합**을 만든다.
3. 해당 조합들로 **테스트**를 구성한다.

### addWater 메서드 테스트

#### 1. 특성 선택

1. 데이터 타입을 고려하는 방법
    - 수치 타입에서 0은 다른 값과 산술적 특성이 다르므로 구별하는것이 좋다.
    - 음수값은 대부분의 api에서는 받아들이지 않는 경우가 많다.
    - 모든 참조 타입에 대해 null 값은 특별한 조치가 필요하다.
    - 문자열, 배열, 컬렉션은 비어있는 경우를 고려해야한다.

2. 사전조건과 사후조건을 통해 만들어내는 방법

|번호|특성|블록 |
|---|---|---|
|1|이 수조가 적어도 한 수조에 연결됨|{true, false}|
|2|인자와 그룹에 담긴 물의 양 사이의 관계| {양수, 0, 유효한 음수, 유효하지 않은 음수}|


#### 2. 블록 조합 선택
여러가지 방식이 있지만 대표적으로 3가지를 소개.
- 전체 조합 커버리지 : 모든 조합을 테스트 하는것. -> 경우의 수가 많으면 어렵다.
- 개별 선택 커버리지 : 모든 블록이 적어도 한번씩 테스트에서 사용되는 것.
- 기반 선택 커버리지 : 하나의 기준이 되는 조합을 정한 뒤, 하나의 블록의 모든 값이 등장할때까지 해당 블록의 값만 바꾸는 방식.

#### 3. 실제 값 선택
하나의 조합을 선택해서 테스트한다.

```java
    @Test
public void testAddValidNegativeToConnected() {
        a.connectTo(b);
        a.addWater(10);
        a.addWater(-4);
        assertThat(a.getAmount()).isEqualTo(3);
}
```

이 방식의 문제는 하나의 테스트에서 너무 많은 테스트가 이뤄진다. connectTo, addWater, getAmount 세가지 메서드를 모두 테스트하는꼴.
테스트가 통과되지 않아도 어떤 메서드에서 문제가 발생했는지 알수가 없다.

### connectTo 테스트
- 서로 독립적이지 않은 특성들이라면 조합의 수를 줄어든다.
- 하나의 특성값이 사전 조건을 위반해 예외가 발생하면 모든 경우가 아닌 한번만 테스트해도 된다.


## Jacoco
- 자바 코드 커버리지를 체크하는데 사용하는 오픈소스 프레임워크
- html, xml, csv 등의 형태로 리포트를 얻을 수 있다.

3가지 기준을 측정할 수 있다.
1. 명령어 커버리지 : 실행된 바이트코드 명령어의 비율
2. 라인 커버리지 : 실행된 자바 코드 행의 비율. 무조건 명령어 커버리지보다 크다.
     ```java
    void foo (int x) {
        system.out("start line"); // 1번
        if (x > 0) { // 2번
            system.out("middle line"); // 3번
        }
        system.out("last line"); // 4번
    }
    ```
3. 브랜치 커버리지 : 실행된 조건 분기의 비율.
   - 모든 조건문에 대해 true, false를 반환하는지

- [코드 커버리지](https://seller-lee.github.io/java-code-coverage-tool-part1)
- [Jacoco 적용](https://seller-lee.github.io/java-code-coverage-tool-part2)


## 테스트 용이성
단위 테스트의 조건

- 입력을 제공할 수 있어야 함 (제어 가능성)
- 입력의 효과를 관측할 수 있어야 함 (관측 가능성)
- 각 단위 테스트가 서로 의존성을 가지면 안됨

### 1. 제어 가능성
- 단위 테스트에 특정 입력을 제공하는 것이 얼마나 쉬운지를 나타낸다.
  - 클라이언트에게 직접 입력을 받는 경우 -> **제어가능성이 높다**
  - 파일 혹은 네트워크로부터 입력값을 받아오는 경우 -> **제어가능성이 낮다**

### 2. 관측 가능성
- 관측 가능성을 높이기 위해서는 메서드가 값을 리턴하도록 하는것이 좋다.
  - Collection의 add 메서드는 삽입 성공 시 true를 반환한다.

### 3. 의존성 제거
실제 서비스는 여러 클래스가 의존성을 가지고 있기 때문에 고립된 상태로 테스트하는것이 어렵다.
이런 문제는 **의존성을 주입**시켜서 해결할 수 있다.

```java
public Container(Set<Container> emptySet) {
    group = emptySet;
    group.add(this);
}
```

### 의존성 주입의 단점
- 외부에 클래스의 구현을 노출시키게 된다. 어떤 타입의 객체가 필요한지 외부로 드러나게 된다.
  - 테스트 용이성 향상과 캡슐화 훼손 사이의 균형이 중요하다.
- 호출하는 쪽에서 매번 새로운 객체를 생성해야하며, 원하는 형태와 다른 형태의 객체를 넘겨줄수도 있다. -> 오류로 이어질 수 있다.
  - _이런 단점은 함수 내에서 예외처리를 해주거나, 해당 객체를 clone하는 방식으로 해결 가능._
  - 리플렉션을 사용해서 처리할수도 있다.
  > 리플렉션 : 구체적인 클래스 타입을 몰라도 해당 클래스의 메서드, 변수에 접근할 수 있도록 해주는 Java Api
  
  ```java
    public Container(Class<? extends Set<Container>{}> setType) throws ReflectiveOperationException{
        group = setType.getDeclaredConstructor()
                    .newInstance();
        group.add(this);
    }
  ```
  
스프링의 경우 `@AutoWired` 어노테이션이 존재한다.
```java
class Foo{
    private Boo boo;
    
    public Foo() {
        boo = new Boo();
    }
    
    @AutoWired
    private Boo boo;
}
```
이런식으로 프레임워크에게 객체를 관리하도록 위임하는걸 **제어 역전**이라고 한다.

### 모킹
- 테스트 코드를 작성할때 의존성을 가진 객체를 다른 가짜 객체로 대체해서 테스트를 하는 테스팅 기법이다.

자바에서는 Mockito라는 프레임워크를 사용한다.

1. gradle에 의존성 추가
```
    testImplementation "org.mockito:mockito-core:3.+"
```

2. mock객체를 생성한다.
```java
class ServiceMock {
    public void send(String data) {
        //...
    }
}
```
3. 실제 객체를 주입해야하는 위치에 mock객체를 넣는다.
4. 해당 객체의 메서드가 호출되었는지 검사한다.


## 핵심
- 입력 도메인 모델
- 코드 커버리지
- 테스트 용이성
  - 제어 가능성
  - 관측 가능성
  - 의존성 주입 / 가짜 객체
