## 모니터링을 이용한 신뢰성 향상

소프트웨어의 신뢰성은 다양한 작동 환경에서 시스템이 원하는 대로 작동하는지 여부.

### 계약에 의한 설계 방법론

- 메서드마다 계약을 부과한다.
- 불변 조건이 항상 성립해야 한다.

#### 1. 사전 조건
- 메서드가 올바로 기능하는데 필요한 요구사항을 기술한다.
  - 적법한 파라미터 값
  - 현재 객체 상태 등등
- 호출자가 제어할 수 있는 성질의 조건만 포함할 것.
- 호출하는 곳에서 사전 조건을 지켜야 할 책임을 가지고 있다.
  - 호출자 : 의무 / 피호출자 : 이득


#### 2. 사후 조건
- 메서드의 효과, 리턴값, 관계된 객체들의 상태 변화를 기술한다.

#### 3. 페널티

- 사후 조건 내에 속해 있는 영역.
- 사전 조건을 어겼을 경우 발생하는 문제들을 기술한다.
- 자바에서는 주로 확인되지 않은 예외를 던지는 것이다.

#### <확인된 예외와 확인되지 않는 예외>
1. **확인된 예외** : 컴파일러가 검사한다.
   - Exception 클래스의 하위 클래스들, Error 클래스의 하위 클래스들.
   - 이런 예외가 존재할 경우, 컴파일 자체가 되지 않는다.

2. **확인되지 않는 예외** : 컴파일러가 검사하지 않는다.
   - RuntimeException 클래스의 하위 클래스들.
   - 이런 예외가 존재하더라도 문제없이 컴파일 된다.


### 불변 조건
- 메서드의 실행 전/후 항상 성립해야 한다.
- 불변 조건을 검증할 책임은 public 메서드가 가진다.

## 정확성과 견고성
소프트웨어의 신뢰성은 정확성과 견고성으로 세분화할 수 있다.

### 정확성
- 시스템이 정상 환경이라고 가정하고 측정. 기대한 인자값과 올바른 리턴값이 반환되는 등 기대한 환경에서의 동작을 측정한다.

### 견고성
- 예외적이고 예상하지 못한 환경에서 시스템이 어떻게 동작하는지를 다룬다. 사전조건이 성립하지 않는 상태 등에서 측정.
- 즉, 예외처리를 잘해야 한다는 말.


## 계약 구현과 강제를 위한 3가지 코딩 기법
1. if 기반 검사 : 호출자가 사전 조건을 지키는 방식으로 메서드를 호출했는지 확인 후, 그렇지 않을 경우 페널티 발생
2. assert 구문 : 사전 조건과 불변 쪼건을 확인하는데 유용
3. 테스트 : 사후 조건을 검사하고 페널티 발생시킴.

## 계약 검사
- 사전 조건과 사후 조건, 불변 조건을 검사하는 작업을 의미한다. 
  - 어겼을 경우, 예외를 던진다. (방어적 프로그래밍이라고 부른다)
  - IllegalArgumentException, IllegalStateException 을 주로 사용한다.
- assertion 구문 : 불리언 조건을 평가해서 거짓일 경우 Assertion Error을 던짐
    - if문과의 차이는 JVM은 assertion 구문을 실행하지 않는다.
    ```java
    assert condition : "Error Message!";
    ```
- public 메서드의 사전 조건은 항상 확인해야 하므로 if를 이용할 것
- 사후 조건, 불변 조건, private 메서드의 인자 검사는 assertion 이용.

## 불변 조건 검사
- 클래스의 속성이 메서드가 실행되는 동안을 제외하고는 항상 가져야하는 정적 일관성 속성을 의미한다.


## 신뢰성에 기여할 수 있는 2가지 요소

### 1. 수동 검증
- 동료 개발자와 함께하는 페어 프로그래밍 or 코드리뷰

### 2. 자동 검증
- 스타일 검사기 : 가독성과 통일성을 위해 사용하는 도구. 들여쓰기등의 검사.
- 정적 분석기 : 컴파일러의 타입 검사단계와 같은 의미론적 분석이 가능한 도구
- 형식 검증기 : 주어진 모든 값의 집합에 대해 프로그램 실행을 시뮬레이션 할 수 있는 도구.

## NullPointerException vs IllegalArgumentException
- 어느 값 때문에 문제가 발생했는지 명확할 경우  -> NullPointerException
- 사전 조건 위반으로 문제가 발생한것이 명확하거나, JVM이 만들어내는 NPE와 명확하게 구별될 경우 -> IllegalArgumentException


## 돌발 퀴즈
Q1. 페널티로 확인된 예외를 던지지 않는 이유는 무엇일까?  
A. 그럼 사용자가 직접 처리해줘야해서.

Q2. 프로그램이 종이에 인쇄한다면 종이가 떨어졌을 때 우아한 대처법은 무엇인가?  
A. 동작을 멈추고 종이를 다시 채워넣으라고 사용자에게 메세지를 보낸다.

Q3. "addWater에 0을 전당하면 모든 수조에 변화가 일어나지 않는다" 라는 조건은 Container 클래스의 유효한 불변 조건인가?
A. 이전의 상태와 현재의 상태를 비교하는 경우이기 때문에 아니다.

Q4. 어서션이 활성화됐을 때만 불리언 플래그를 true로 설정하는 방법은 무엇일까?  
A. 플래그를 false로 초기화하고 assertion 내에서 true로 설정

Q4. addWater에 NAN을 인자로 전달하면 어떻게 될까?  
A. NAN에 대한 산술연산은 NAN을 반환하고, 비교 연산은 false를 반환하기 때문에 코드는 계속 동작한다. 수조에 결국 NAN이 저장될 것.


## 연습문제
1-1. Collection 인터페이스의 add 메서드의 계약을 작성해보자.

- 사전 조건 : 인자로 들어오는 값이 null이 아닐것을 보장해야한다.
- 사후 조건 : 해당 Collection에 저장을 한 뒤, true를 반환한다.
- 페널티 :
    - 해당 컬렉션이 add 메서드를 지원하지 않을 경우 UnsupportedOperationException.
    - 인자의 타입이 알맞지 않을 경우 ClassCastException.
    - 인자가 null이면서 해당 컬렉션이 null을 저장하지 못할 경우 NullPointerException.
    - 인자의 특정 조건때문에 저장이 안될경우? IllegalArgumentException.
    - 현재 컬렉션의 상태때문에 저장이 안될경우 IllegalStateException.

1-2. HashSet 클래스의 add 메서드에도 같은 작업을 해보자.


- 사전 조건 : 
- 사후 조건 : 해당 컬렉션 내부에 중복되는 요소가 없을 경우 저장한 뒤 true를 반환한다. 이미 중복 요소가 있을 경우 false 반환
- 페널티 :


3-1. private 생성자의 계약을 작성해보자. 생성자가 정상적으로 종료하는데 필요한 모든 조건을 사전 조건에 포함하자. 생성자가 사전 조건을 능동적으로 검사하는가?
- 사전 조건: 정수 형태의 길이가 1이상인 배열이 들어와야한다.
- 사후 조건 : 2의 보수 형태의 값을 이진법으로 가지고 있는 val을 BigInteger로 변환한다.
- 페널티 : 배열의 길이가 0일 경우 NumberFormatException.

3-2. parseInt 메서드에도 같은 짝업을 해보자.
- 사전 조건 : start가 end보다 작아야한다. char의 길이보다 둘 다 작아야한다.
- 사후 조건 : start, end 인덱스 사이의 값을 정수로 변환해서 반환한다.
- 페널티 :
  - 변환할 수 없는 값이 있을 경우 NumberFormatException.