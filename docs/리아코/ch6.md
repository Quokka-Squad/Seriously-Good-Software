## 요약, 정리  

  - ### 코드 기반 커버리지
    - 주어진 테스트 집합에서 한 번이라도 실행되는 소스 코드의 비율
    - ***화이트박스 테스트*** 와 관련 있다
      - 화이트박스 테스트: 테스트할 소프트웨어의 내부 관련 지식과 소스 코드를 인지한 상태에서 진행하는 테스트

  - ### 입력 기반 커버리지
    - 테스트할 프로그램의 내부는 무시하고 API에 집중한다
    - 가능하면 입력의 전체 집합을 분석하고 전체를 대표하는 더 작은 값의 집합을 도출해야 한다
    - SUT의 소스 코드에 독립적이라는 점에서 블랙 박스 테스트와 관련 있다.

    > 다양한 입력 값을 선택할 수 있는 테스트 슈트를 설계하고 테스트의 코드 커버리지를 도구를 이용해 측정한다
      입력 기반 커버리지를 목표로 삼고 테스트 계획 자체를 검증하는 방법으로 코드 기반 커버리지를 사용한다

  - ### 테스트와 계약에 의한 설계
    1. 테스트를 이용하면 불변 조건과 사후 조건 검사를 클래스 밖으로 옮길 수 있다
        - 클래스를 작고 단순하게 유지하는 것은 물론 책임 경계가 명확해지고 조직적 측면에서 개발과 테스트를 다른 팀에 맡길 수 있다
    <br><Br>
    2. 테스트를 하려면 SUT에 제공할 입력 값의 집합을 세심하게 설계해야 한다
        - 주어진 메서드를 다양한 입력으로 호출해보는 체계적인 방법(테스트 계획)이 없으면 프로그램 개발과 배포의 어느 단계에서든 버그를 찾아내지 못한다
        - 커버리지 척도를 바탕으로 SUT의 정확성과 견고성의 신뢰도를 가늠할 수 있다

    > 현대적인 테스트는 변화하는 테스트 집합을 빠르고 반복적으로 실행하는 능력에 바탕한다

  - ### 자바 애노테이션
    - 프로그램 구성 요소에 메타데이터(추가적인 정보)를 첨부하는 일반적인 수단으로 이용한다
    - 바이트코드에 전달돼 런타임에 리플렉션을 이용해 읽어 들일 수 있다
    - 메서드는 물론 클래스와 필드, 지역 변수, 메스드 인자 등에 애노테이션을 첨부할 수 있다

  - ### 일반적인 입력 타입별 표준 특성(타입 기반 특성) p.230

  - ### 입력 커버리지 기준
    - 개별 선택 커버리지: 각 특성에서 파생된 모든 블록이 적어도 한 테스트에서 사용돼야 한다 (p.231 예시)
    <br><br>
    - 기반 선택 커버리지: 기반이 되는 블록 조합을 선택한 후 어떠한 특성의 모든 값이 등장할 때까지 해당 특성 하나만 변경한다 (p.231 예시)

  - ### 관측 가능성
    - 더 많은 정보를 노출하고 테스트 용이성을 높이기 위해 API에 메서드를 추가하는 것이 직관적이다

  - ### 테스트 용이성 개선
    - 외부적인 동작과 관련 있는 모든 정보를 조회할 수 있어야 한다(클라이언트가 인지하는 모든 연산에 영향을 미치는 모든 정보)
    <br><br>
    - 내부적인 객체 리스트의 불변 뷰를 클라이언트에게 리턴한다
      - 불변 뷰: 원본 리스트를 감싸면서 리스트를 수정하는 모든 메서드를 차단한다
      ```java
      public List<T> content() {
        return Collections.unmodifiableList(data);
      }
      ```
      - 단점: 리턴 타입이 많은 의미를 내포한다 즉, 내부적인 표현을 다른 방식 예를 들어 배열로 바꾼다면 구현이 훨씬 복잡해진다
    <br><Br>
    - 불변 뷰 단점을 해결하는 방법
      - ***집합 내용에 대한 읽기 전용 반복자를 리턴한다***
      - 반복자의 remove 메서드를 차단한다
      ```java
      public class BoundedSet<T> implements Iterable<T> {
        public Iterator<T> iterator() {
          return Collections.unmodifiableList(data).iterator();
        }
      }
      ```

    > - 한 테스트에서 어서션을 한 번만 사용해야한다, 즉 단위 테스트가 실패하는 이유는 오직 한 가지여야한다  
    > - 오류 메시지 덕분에 테스트가 실패한 원인을 쉽게 알 수 있기 때문에 코드를 추가해야 할 만큼 복잡한 테스트가 아니라면 위의 규칙을 어겨도 괜찮다  
    > - 사후 조건은 메서드가 의도하는 효과를 기술하므로 테스트가 검사해야 할 어서션을 짚어준다  
  
## 고민 사항 / 중점적으로 리뷰받고 싶은 부분

_<!-- 함께 고민해주었으면 하는 부분 -->_
