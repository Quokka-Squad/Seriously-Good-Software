## 요약, 정리
  - ### 사전 조건
    - 메서드가 올바로 기능하는데 필요한 요구 사항을 말하며 파라미터의 적법한 값과 (인스턴스 메서드의 경우) 현재 객체의 적법한 상태를 기술한다.
    - 호출할 메서드의 사전 조건을 지키는 것은 호출자(호출하는 쪽)의 책임이다
    - 호출자가 완벽하게 제어할 수 있는 성질의 조건만 포함해야 한다.
  <br>
  - ### 사후 조건
    - 메서드의 효과와 리턴 값, 관계된 모든 객체의 상태 변화를 기술한다.
    - 호출자가 사전 조건을 어겼을 때 어떠한 일이 발생하는지 즉 패널티도 명시해야 한다.
    - 자바에서 주로 사용하는 패널티는 확인되지 않은 예외를 던지는 것이다
      - ⚠ ***호출자가 직접 통제할 수 없는 경우***에만 확인된 예외를 던지게 하자
    - 사후 조건은 메서드 호출로 야기되는 몯느 변화를 기술하므로 다음과 같은 데이터를 언급한다.
      - 리턴 값(메서드의 주요 효과)
      - 🤔 객체의 이전 상태와 새로운 상태: 이전 상태는 메서드의 동작에 영향을 미치는 입력이고 새로운 상태는 메서드로 인한 결과 중 하나다.
      - 입력으로 주어진 인자의 값
      - System.out.println 호출처럼 전역적으로 접근 가능한 객체나 정적 메서드로 인한 부수효과
  <br>
  - ### 불변 조건
    - 🤔 클래스 필드에 대해 항상 참인 조건
    - 🤔 불변 조건은 항상 현재 상태만 가리킨다.
    - 메서드가 실행되는 동안, 클래스가 변화하는 동안을 제외하고 항상 성립해야한다.
      - 불변 조건은 특정 시점의 객체 상태를 기술하는 ***정적 일관성 규칙*** (static consistency rule)
      - 사후 조건은 메서드 실행 전후의 객체 상태를 비교하는 ***동적 일관성 규칙*** (dynamic consistency rule)
    - 🤔 불변 조건은 메서드 실행 전후 항상 성립해야 한다.
      > 생성자로 인해 조성되는 객체의 초기 상태도 불변 조건을 만족해야 하고 모든 public 메서드는 이를 검증할 책임을 진다.
      ***private 메서드의 주 목적은 public 메서드를 지원하는 역할이므로 불변 조건을 검증할 책임은 없다.***
      private 메서드는 주로 다른 public 인스턴스 메서드에 의해 직.간접적으로 호출된다.
      즉 객체 상태가 변화하는 도중이므로 private 메서드 입장에서는 불변 조건에 맞지 않는 중간 상태를 관찰하게 되며 이러한 일관적이지 않은 상태를 내버려둘 수밖에 없다.
      public 메서드가 실행된 후에야 객체 상태가 일관성을 회복해 불변 조건이 성립한다.
  <br>
  - 순수 메서드
    - 값을 리턴하는 것만이 유일한 효과인 메서드
  - 부수 효과
    - 인스턴스 필드 수정을 비롯한 기타 모든 결과
  - 참조 투명성
    - 같은 인자로 순수 메서드를 두 번 호출하면 그 결과도 같아야하는 성질
  <br>
  - 소프트웨어 신뢰성은 정확성과 견고성 2가지 품질로 세분화할 수 있으며 둘의 차이는 시스템 환경을 어떻게 가정하느냐에 달려 있다. p.180
  - 정확성을 측정할 때는 시스템이 정상 환경이라고 가정한다
    - 기대한 환경이 주어진다는 가정하에 시스템이 계획대로 작동한다는 뜻
    - 완벽하게 성립하거나 전혀 성립하지 않는 불리언 (Boolean) 속성이다.
    - 부분적인 정확성은 존재하지 않는다.
  - 견고성은 예외적이고 예상하지 못한 환경에서 시스템이 어떻게 동작하는 지를 다룬다.
  - 정확성은 ***계약과 사전, 사후 조건의 비교, 클래스 불변 조건*** 을 바탕으로 정의된다.
  - 페널티는 호출자가 사전 조건을 어기는 경우에만 발생하므로 견고성과 관련 있는 주제이며 정확성과 직접적인 관련은 없다.
  <br>
  - ### 계약 검사
    - IllegalArgumentException: 인자 값이 사전 조건을 위반함
    - IllegalStateException: 현재의 객체 상태가 호출된 인스턴스 메서드와 호환되지 않거나 주어진 인자 값과 호환되지 않는다. 이미 닫힌 파일에 읽기를 시도하면 이러한 예외가 발생한다.
    - UnsupportedOperationException, ClassCastException, NumberFormatException, ArrayIndexOutOfBoundsException
    - ***NullPointerException 과 IllegalArgumentException***
      - 인자 값이 원하지 않는 null일 때 NPE와 IAE 중 어느 것을 던져야 하는가?
      - 어느 값 때문에 문제가 발생했는지 명확할 때: NullPointerException
      - 사전 조건 위반으로 문제가 발생한 것이 명확할 때: IllegalArgumentException
      - JVM이 만들어내는 NullPointerException과 명확하게 구별될 때: IllegalArgumentException
    - public 메서드의 사전 조건은 항상 확인해야 하므로 if 를 이용한다.
    - 사후 조건과 불변 조건, public 이 아닌 메서드의 사전 조건을 비롯한 다른 모든 확인은 개발하는 동안에만 수행한다. 따라서 어서션을 이용한다.
    - ***사후 조건과 불변 조건 위반은 클래스 자체의 문제다.***
      >***내부적인 문제*** 란 클래스의 클라이언트가 계약에 명시된 모든 규칙을 지켰느네도 불구하고 버그가 발생하는 것을 말한다. 
      프로그램이 오작동하는 유일한 방법은 다른 클래스를 잘못 사용하는 클래스가 존재하는 것이고 적절하게 캡슐화된 시스템에서 이러한 일은 public 메서드를 통해서만 일어날 수 있다. 
      따라서 ***public 메서드의 사전 조건을 확인***만 해도 이러한 버그를 드러낼 수 있다.
    - 작은 클래스를 작성하는 것은 OOP의 불문율 중 하나다.
    - 각 클래스의 개발과 테스트를 거친 후에는 내부적인 문제가 없다.
  <br>
  - ### 연습문제 1
    - ⚠ 현재 상태에서 인자를 삽입할 수 없으면 ***IllegalStateException***을 던진다.
    - ⚠ 어떠한 조건에서 삽입으로 인해 컬렉션이 변경되는지를 명시하지 않는데 이는 ***서브 클래스의 몫***이다.
  
## 고민 사항 / 중점적으로 리뷰받고 싶은 부분
토론 토론~
_<!-- 함께 고민해주었으면 하는 부분 -->_
