## 요약, 정리
  - HashSet을 비롯한 표준 컬렉션은 메모리 부담이 크다.<br>

  - 😀 ***CPU 캐시***: 주 메모리와 CPU 사이의 성능차를 줄여주는 메모리 버퍼, 소량의 이웃한 데이터를 저장한다.
    - 한 객체 안의 모든 필드는 메모리상에서 가까운 곳에 저장되고 한 필드에 접근하면 다른 필드의 접근도 빨라질 수 있다.
    - 프로그램이 새로운 메모리 위치에 접근할 때 그 위치의 주소에서 시작해 한 라인에 해당하는 영역을 통째로 옮긴다.<br>

  - 자바에서 캐시 지역성을 활용하면서 데이터를 저장하려면 일반 배열이나 배열을 바탕으로 한 ***ArrayList*** 와 같은 클래스를 사용해야 한다.
  - 😀 ArrayList를 비롯한 제네릭 클래스는 참조만 저장하므로 캐시 지역성도 참조 자체에 국한되며 참조가 가리키는 데이터(객체)에는 적용되지 않는다.
    - ArrayList<Integer>는 Integer의 참조를 배열에 저장하는데 참조 자체는 이웃한 메모리 위치에 저장되지만 실제 정수 값은 그렇지 않다.<br>
    
  - 팩터리 메서드: 클래스의 새로운 인스턴스를 리턴하는 메서드
  - 🤔 FACTORY METHOE: 클라이언트에게 객체를 제공하되 서브클래스에서 객체의 실제 타입을 정할 수 있다.<br>

  - 인스턴스화 불가능 클래스
    - 클래스가 아닌 인터페이스로 선언하기
    - 클래스를 abstract로 선언하기
    - (유일한 생성자로) private 생성자 만들기
      - 인스턴스화와 상속을 동시에 방지한다.
      - 해당 클래스를 확장하려고 하면 서브클래스의 생성자에서 의무적으로 호출해야 하는 슈퍼클래스의 생성자에 접근할 수 없다.

  - 😀 부동 소수점 수는 정수보다 범위가 넓지만 ***해상도(resoulution)*** 가 가변적이다.
  - 연속한 두 float 사이의 거리는 수의 크기에 따라 변한다.
  - 특정 지점 이후로는 그 거리가 1보다 커지고 float 값이 정수를 지나친다.
  - float 는 범위가 넓어 1E10(10^10, 즉 100억)을 정확하게 표현할 수 있다.
    - float 과 정수 타입 모두 1E8(1억)을 표현할 수 있지만 값이 1E8인 float 변수에 1을 더하면 여전히 1E8이다.
    - 100,000,000이라는 수를 표현하기에는 float가 가진 수가 부족하다. 즉, 1E8과 다음 float 값 사이의 거리가 1보다 크다.
    - float의 전체 범위에는 1E8이 충분하게 포함되지만 무간섭 정수 범위(uninterrupted integer range) 즉 편차 없이 정확하게 표현 가능한 정수 범위 밖에 있다.<br>

  - 캐시 지역성 덕분에 데이터를 연속된 메모리 영역에 저장하면 성능을 개선할 수 있다.<br>

  - 🤔 ***문자열 인터닝(string interning)*** 기법을 이용해 각 문자열 리터럴의 사본 하나만 실제로 메모리에 저장한다.
  - 🤔 자바9 이후부터는 ***콤팩트 문자열(compact string)*** 기능으로 인해 문자열에 ASCII 문자만 포함된 경우 문자당 한 바이트로 인코딩한다.<br>

  - 컴파일러는 제약 없는(unbounded) 타입 파라미터를 지우고 Object 로 대체한다.
  - 배열은 정적 타입을 저장한다(이를 이용해 배열에 대한 쓰기 연산의 유효성을 확인한다.)
    - 자료형을 컴파일 시에 결정, 컴파일 시에 자료형에 맞지 않은 값이 들어있으면 컴파일 에러가 발생한다.<br>

  - 싱글톤 클래스는 로우 레벨 서비스로의 단일 접근 지점을 만드는 일반적인 방법이다.
    - 메서드를 처음 호출하는 시점에서 하나뿐인 인스턴스를 생성(지연 초기화)한다면 스레드 안전성 문제에 주의해야 한다.<br>
    
  - CPU가 가리킬 수 있는 메모리의 최소 단위는 바이트(Byte)이다.

## 고민 사항 / 중점적으로 리뷰받고 싶은 부분

_<!-- 함께 고민해주었으면 하는 부분 -->_
