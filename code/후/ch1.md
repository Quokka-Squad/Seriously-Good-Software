# 1장_소프트웨어 품질과 앞으로 풀어야할 문제

### ✔️ check point

- 서로 다른 관점과 목적에서 소프트웨어 평가하기
- 내적(internal) 소프트웨어 품질과 외적(external) 소프트웨어 품질 구별하기
- 기능적(functional) 소프트웨어 품질과 비기능적(nonfunctional) 소프트웨어 품질 구별하기
- 소프트웨어 품질 기준 사이의 상호작용과 상충성(trade-off)

---

## 소프트웨어 품질

- 소프트웨어의 전반적인 가치가 아닌 소프트웨어가 지녀야 할 특정한 특성
- 내적(internal) 품질 vs 외적(external) 품질
- 기능적(functional) 품질 vs 비기능적(nonfunctional) 품질

## 내적 품질과 외적 품질

- 외적 품질 : enduser가 시스템과 상호작용하는 동안 인지할 수 있는 품질
    - 정확성, 견고성, 스레드 안정성, 효율성, 사용성
- 내적 품질 : 소스 코드를 봐야만 알 수 있는 품질
    - 가독성, 간결성, 재사용성, 유지보수성
- but, 사용자는 내적 품질을 일부 간접적으로 체험할 수 있고 모든 외적 품질은 소스 코드에 의존

## 기능적 품질과 비기능적 품질

- 기능적 품질 : 소프트웨어가 무엇을 하는가
    - 소프트웨어가 뭔가 수행하면 그 효과를 enduser가 체감. 따라서 모든 기능적 품질은 외적 품질
    - 정확성, 견고성, 스레드 안정성
- 비기능적 품질 : 소프트웨어가 어떻게 하는가
    - 그것이 코드 자체와 관련되느냐, 코드로부터 파생된 특성과 관련되느냐에 따라 내적 품질 또는 외적 품질
    - 사용성, 효율성, 가독성, 간결성, 재사용성, 유지보수성
- 이 사이에서 균형 잡기!

## 정확성(correctness)

- 요구 사항이나 명세를 얼마나 만족시키는지 → 신뢰성(reliablity)
- 개발자 스스로 달성할 명세를 명확하게 이해하지 못하면 정확성도 달성할 수 없다!
    - 무지성으로 요구 사항 그냥 한줄씩 읽어가며 바로바로 구현하다가 나중에서야 엇 이게 아닌데... 하며 뜯어 고치다 결국 처음부터 다시 해야했던 경험... 해봤으면서 왜
      자꾸 제대로 이해하기도 전에 코딩부터 시작하는지ㅠㅠㅠ...
- 명세를 규약(contract) 관점에서 바라보고 그 규약을 지키도록 구현
- 가독성 높은 테스트 케이스 설계

## 견고성(robustness)

- 잘못된 입력이나 예상하지 못한 외부 조건에 대한 복원력 → 신뢰성(reliablity)
- 유효한 입력인지 확인(validation check)
- 치명적인 오류가 발생할 때 사용자 데이터와 그 시점까지 수행한 계산 결과를 최대한 저장한 후 중단
- 엄격한 명세와 메서드 규약, 클래스 불변 조건의 런타임 모니터링

## 사용성(usability)

- 소프트웨어 사용법을 배우고 그 목표를 달성하는 데 필요한 노력 정도
- ui/ux 디자인과 밀접한 관련

## 효율성(efficiency)

- 자원(시간, 공간)을 얼마나 소모하는지
- 시간 복잡도, 공간 복잡도
- 내/외적 품질, 기능/비기능적 품질인지 모호. 경우에 따라 어떤 것도 될 수 있다.

## 가독성(readability)

- 미래의 나와 동료 프래머가 명확하게 이해할 수 있는지
- 변수명, 메서드명...

## 재사용성(reusablity)

- 유사한 문제를 해결하기 위해 코드를 재사용할 수 있고, 이를 위해 필요한 변경이 적은지 (=적응성)
- 라이브러리, 프레임워크

## 테스트 용이성(testability)

- 프로그램의 모든 동작을 촉발하고 그 효과를 관측하는 테스트를 쉽게 작성할 수 있는가?
- 테스트 가능한 코드 - 호출자가 모든 예상 동작을 검증할 수 있는 API 제공
    - ex) 프로시저(void)는 결과 값을 리턴하는 메서드보다 테스트하기 어려움

## 유지보수성(maintainability)

- 버그를 쉽게 찾아 수정하고 소프트웨어를 발전시킬 수 있는지
- 분석하기 쉽고 모듈화가 깔끔하게 → 명확하게 정의된 역할과 명확하게 정의된 방식으로 상호작용하는 구성 요소
- 테스트 용이성과 가독성에 영향을 받는다

## 스레드 안정성(thread safety)

- 멀티스레드 환경에서 매끄럽게 작동하는가(동시성 제공)
- 스레드 안정성 문제는 무작위적이고 재현하기 어려워 발견하기 힘든 버그를 야기

## 간결성(succinctness)

- 주어진 작업을 수행할 수 있는 가장 짧은 프로그램
- 일반적으로 코드 품질과 관련이 없지만, 이를 목표로 삼아야 하는 경우도 있음
    - 스마트카드 같은 저사양 임베디드 시스템

## 소프트웨어 품질 기준 사이의 상호작용

- 가독성, 유지 보수성 ↔ 시간 효율성, 공간 효율성
    - 최대 성능을 얻으려면 추상화 대신 저수준 코드 작성
- 시간 효율성 ↔ 공간 효율성
    - 성능 향상을 위해 필요할 때마다 계산하는 대신 메모리에 추가 정보 저장
- 견고성 ↔ 시간 효율성
    - 비정상적인 상황을 확인하고 적절한 방식으로 대응하는 코드 추가 → 성능 부담
- 개발 시간 ↔ 소프트웨어 품질
    - 비스니스상의 이유로 빠르게 개발해야 하지만, 품질을 최대화하려면 시간을 들여야함
- 소프트웨어 척도 - 소프트웨어의 일부를 정량화할 수 있는 속성
    - 코드 라인 수(LOC)
    - 순환 복잡성(cyclomatic complexity) : nesting, branching 정도를 나타내는 척도
